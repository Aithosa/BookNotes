# 一些解释

## 第一章

### 1.1 Lambda 表达式/函数式编程和并行之间有什么必然关系吗？

从理论上讲，Lambda 表达式/函数式编程与并行没有绝对的必然关系（你可以写单线程的函数式代码，也可以不用 Lambda 写并行代码）。 但在 Java 8 的设计背景下，二者有极强的因果关系：为了让开发者能更容易地编写利用多核 CPU 的并行代码，Java 需要引入 Lambda 表达式。

1. **Java 8 引入 Lambda 的核心动力是 "并行"**

   > “为了编写这类处理批量数据的并行类库， 需要在语言层面上修改现有的 Java： 增加 Lambda 表达式。”

   在 Java 8 之前，处理集合（Collection）通常使用 for 循环（外部迭代）。这种方式很难自动并行化，因为控制权在开发者手中，且容易涉及共享的可变状态。 为了让库（如 Stream API）能自动接管迭代并进行优化（包括并行处理），Java 需要一种简洁的方式将“要做什么”（行为/代码）传递给库。Lambda 就是这种传递行为的载体。

2. **函数式编程让并行更 "安全"**。 虽然 Lambda 只是语法糖，但函数式编程的核心思想（不可变性和无副作用）是并行编程的救星。

- 传统并行：需要处理复杂的锁、线程同步，因为多个线程可能同时修改同一个变量。
- 函数式并行：如果你的 Lambda 表达式是“纯函数”（不修改外部状态，只根据输入计算输出），那么这个函数发给 100 个线程同时跑也是绝对安全的，完全不需要锁。

总结： 并不是因为有了 Lambda 就一定会有并行（很多 Lambda 只是为了代码简洁），而是为了让并行编程变得像“调个 API”一样简单（Stream.parallel()），Java 必须引入 Lambda 表达式和函数式编程的理念来避免传统并发编程的陷阱。

### Lambda 表达式/函数式编程的关系

Lambda 表达式不是“函数式编程”本身，而是实现函数式编程的一种工具（语法手段）。

- 函数式编程 (FP) 是一种编程思想/范式（就像“面向对象”是一种思想）。
- Lambda 表达式 是 Java 为了支持这种思想而引入的语法特性。

函数式编程的两个核心思想：

- **不可变性（Immutability）**：
  - 不修改对象的状态，而是创建新的对象。
  - 例如，创建一个不可变的集合，而不是修改现有的集合。
- **无副作用（Side-Effect-Free）**：
  - 操作不依赖于外部状态，也不影响外部状态。
  - 例如，一个函数只依赖于输入参数，不依赖于全局变量，也不修改全局变量。

1. 相似性

   在 Java 中，Lambda 和不可变性被紧紧捆绑在一起。 如果你尝试在 Lambda 表达式里修改一个局部变量，编译器会直接报错。Java 的这个设计强行让 Lambda 表达式具备了 **“闭包”的不可变特性**。这就在语法层面引导你去写“无副作用”的代码——这正是函数式编程的核心及其“不可变性”的要求。

2. 区别

   - **Lambda 只是个壳子**：你可以用 Lambda 写出完全不“函数式”的代码。
     - 反例：虽然不能修改局部变量，但如果你在 Lambda 里修改了外部对象的状态（比如向一个全局 List 里 add 元素），那你依然违背了函数式编程“无副作用”的初衷，虽然你用了 Lambda 语法，但这不算纯粹的 FP。
   - **函数式编程是灵魂**：它的核心是纯函数（输入 -> 输出，不改状态）。
     - 正例：不论是用 Lambda x -> x + 1，还是写一个传统的 public int add(int x) 方法，只要它不依赖也不修改外部状态，它就是符合函数式编程思想的。

如果 Java 允许你在 Lambda 里随意修改外部变量（取消不可变性限制），那么当 Stream 并行执行时，你就会遇到严重的线程安全问题（数据竞争）。 Java 强制 Lambda 遵守“变量不可变”，就是为了让你在不知不觉中写出更容并行化的代码。

总结一句： Lambda 表达式是 Java 给你的剑，函数式编程是剑谱。Java 给剑的时候特意加了个锁（不可变性限制），防止你练剑的时候伤到自己（线程安全问题）。

## 第二章

### 练习 2-b

**DateFormatter 类是非线程安全的**。使用构造函数创建一个线程安全的 DateFormatter 对象，并输出日期，如“01-Jan-1970”。

> 为什么说他是非线程安全的，因为声明之后可以被修改？

这里存在一个常见的误解。SimpleDateFormat 非线程安全不仅是因为它的模式串（Pattern）可以被修改，更致命的是因为**它在这个类的内部维护了“有状态”的中间变量（比如 calendar 字段）**。

简短回答： SimpleDateFormat 在解析或格式化日期时，会修改它内部的一个成员变量 calendar。 如果线程 A 把它改到了“2020 年”，还没来得及读出来，线程 B 突然进来把它改成了“1990 年”，线程 A 读出来的结果就会变成“1990 年”（或者直接报错抛异常）。这就是典型的数据竞争（Race Condition）。

SimpleDateFormat 之所以有公共 Calendar，是因为当年的设计者为了省那一点点创建对象的开销，牺牲了线程安全性。这是 Java 早期最著名的反面教材之一。现在新代码强烈建议直接抛弃它，改用 Java 8 的 DateTimeFormatter。

## 第三章

### 正确使用 Lambda 表达式

> **回调函数是一个合法的 Lambda 表达式，但并不能真正帮助用户写出更简单、更抽象的代码**，因为它仍然在指挥计算机执行一个操作。**明确了要达成什么转化，而不是说明如何转化**。

作者想表达的是：如果你只是用 Lambda 替代了匿名内部类去做以前一模一样的事情（比如点击按钮后修改一个变量），那这只是**“换汤不换药”**（语法糖），并没有利用到函数式编程真正的威力（声明式数据处理）。

1. 为什么说“回调函数……不能真正帮助用户写出更简单、更抽象的代码”？
   解释： 即使你用了 Lambda，这种写法依然是命令式的。你在显式地告诉计算机**“现在去做这个，然后做那个”（修改状态、打印日志）。 这就像你只是把“手写信”换成了“发短信”，但内容依然是“嘿，帮我把楼下的垃圾倒了”。你关心的依然是具体的执行步骤**。只是语法简化了，做的事没有任何变化。
2. 什么是“描述了数据上的操作……明确要达成什么转化”？
   这是函数式编程真正想推崇的声明式写法（主要体现在 Stream API 上）。
   代码：比如任何 Stream 的用法。
   解释： 这里你并没有指挥计算机“先创建一个空列表，然后循环这个人，检查年龄，如果是就加进去，如果不...”。 你只是声明了意图：

   - 输入：人。
   - 转化规则 1：只要未成年的。
   - 转化规则 2：只保留名字。
   - 输出：名字列表。

   这就是作者说的“明确要达成什么转化，而不是说明如何转化”。这种代码没有修改任何外部状态（没有修改 people 列表，没有修改全局变量），它只是通过输入产生输出（而且是新输出）。

3. 为什么“forEach 是唯一的例外”？
   因为 forEach 的本质就是退化回了“命令式编程”。 stream.forEach(x -> System.out.println(x)) 它的意思就是：“对每个元素，执行这个操作（副作用）”。 它不产生返回值（void），只为了产生副作用（打印、入库、发请求等）。所以它是 Stream 里唯一一个“不纯”的、专门用来干脏活累活的操作。

总结： 作者并不是说回调函数不好，而是说：不要以为用了 -> 你就是在做函数式编程了。

如果你用 -> 只是为了方便地修改外部变量（如果 Java 允许的话），那你仅仅是在用一种更短的语法写老式的命令式代码。
Java 8 真正希望你做的是：改变思维模式，尽量写“无副作用”的数据转化链条（输入 A -> 转化 -> 输出 B），而不是到处修改状态。

## 第 4 章

### 4.6 什么是虚方法？

> “现在默认方法成了虚方法——和静态方法刚好相反。”
>
> 什么是虚方法？这不是 C++ 里的吗？我一直不知道 Java 里也有。

**简短回答：**
“虚方法” (Virtual Method) 是面向对象编程的一个通用术语，指**支持多态（Polymorphism）的方法**。
在 Java 中，**除了 `static`、`final`、`private` 之外的所有实例方法，默认全是虚方法**。正是因为“到处都是”，所以 Java 程序员平时反而不怎么挂在嘴边。

---

**详细解释：**

1. **为什么叫“虚”？**
   这个词确实在 C++ 里更常见。

   - **C++**：方法默认是**静态绑定**的（非虚）。如果你想让子类能重写父类的方法并实现多态，必须显式加上 `virtual` 关键字。
   - **Java**：设计者觉得多态太重要了，所以**默认就是动态绑定**（虚）的。你不需要写 `virtual`，它天生就是。

2. **作者为什么要强调这个？**
   作者是为了把 **“默认方法”** 和 **“静态方法”** 做对比。
   - **接口的静态方法 (Static Method)**：它是死板的，编译期就定死了调谁。你不能重写它，它不参与多态。
   - **接口的默认方法 (Default Method)**：它是灵动的（虚的）。虽然它写在接口里，但它表现得就像一个普通的实例方法。**子类可以重写它，调用时也会根据对象的实际类型（Runtime Type）来决定运行哪个版本。**

**总结：**
作者说它是“虚方法”，其实就是在说：**“别因为它写在接口里就小看它，它和类里的普通方法一样，是支持多态和重写的。”**

### 4.8 权衡 (Trade-offs) 中的 Q&A 解释

> **Q：** 在接口中定义方法的诸多变化引发了一系列问题， 既然可用代码主体定义方法， 那 Java 8 中的接口还是旧有版本中界定的代码吗？
> **A：** 现在的接口提供了某种形式上的多重继承功能，然而多重继承在以前饱受诟病， Java 因此舍弃了该语言特性， 这也正是 Java 在易用性方面优于 C++ 的原因之一。

**这段对话的核心矛盾点在于：**
Java 诞生之初有一个**核心卖点**：**“我们不支持 C++ 那种复杂的多重继承，我们只有单继承，所以我们要比 C++ 简单！”**
现在 Java 8 引入了默认方法，允许了一个类实现多个接口并继承它们的代码逻辑。这**听起来**完全就是多重继承。
所以 Q 在问：**“Java 8 是不是打脸了？是不是打破了自己当年的立身之本？”**

**A 的回答是在辩解：**
“是，我们确实引入了多重继承（行为上的），但是我们依然比 C++ 简单和优越，因为我们**去掉了最严重的那个坑——状态（State）**。”

- C++ 的多重继承（以前饱受诟病的原因）：

  - C++ 允许继承多个父类的**成员变量（状态）**。
  - **菱形继承问题 (Diamond Problem)**：如果 A 有个变量 `x`，B 和 C 都继承 A，D 同时继承 B 和 C。那 D 里面到底有几个 `x`？修改 B 的 `x` 会不会影响 C 的 `x`？这会导致内存布局和逻辑极其复杂。

- Java 8 的多重继承（“优于 C++”的原因）：
  - Java 接口**依然不允许有实例成员变量**（只能有 `static final` 常量）。
  - 所以，你只能继承**行为（代码逻辑）**，绝对不会继承**状态（变量）**。
  - 这意味着永远不会出现 C++ 那种“多个父类争夺同一个变量内存”的烂摊子。

**总结：**
这段话的意思是：**“放心，虽然我们允许你到处抄代码（继承行为），但我们依然禁止你到处抄变量（继承状态）。所以 Java 依然保持了‘无菱形状态冲突’的简洁性，没有变成复杂的 C++。”**

### 4.9 接口的静态方法 (Static Methods in Interfaces)

> **原文质疑：**
> Stream 是个接口，`Stream.of` 是接口的静态方法……旨在帮助编写类库的开发人员……
> 人们在编程过程中积累了这样一条经验， 那就是一个包含很多静态方法的类（工具类）……当然， 如果一个方法有充分的语义原因和某个概念相关， 那么就应该将该方法和相关的类或接口放在一起……

**解释：**
这是一个关于 **代码组织风格 (Style)** 转变的问题。
作者的意思是：不仅是工具类，很多以前不得不写成 `XxxUtils` 的类，现在可以直接写在接口里了。

**1. 以前的痛点（Java 7 及之前）：**
接口里**不允许**写静态方法。
如果你想提供一些关于这个接口的通用工具方法（比如“生成一个空的不可变集合”），你被迫去创建一个 **伴生工具类 (Companion Utility Class)**。

- `Collection` (接口) vs `Collections` (工具类)
- `Path` (接口) vs `Paths` (工具类)
- 使用者想用 `Collection`，还得记着有个 `Collections` 类在旁边伺候着，API 是分裂的。

**2. Java 8 的改进：**
Java 8 允许接口写静态方法后，**以后的新代码，别再写 `Xxxs` 这种工具类了，直接写在 `Xxx` 接口里！**
这样实现了 **高内聚**，使用者也不用到处找类了。

- **正例 (Java 8)**：`Stream.of(...)` —— 以前可能得叫 `Streams.of(...)`。现在直接就在 `Stream` 接口里，多直观。
- **正例 (Java 8)**：`Comparator.comparing(...)` —— 以前可能得写个 `Comparators.comparing(...)`。

**结论：**
作者建议你找那种 **“专门服务于某个接口的工厂方法或辅助方法”** 的工具类，把它们迁移到接口内部变成 static 方法。

### 5.3.7 reduce 应该怎么用？

`reduce` 在 Stream API 中主要是 3 种签名，你例子中用到的是最复杂的一种（专门处理输入和输出类型不一致的情况）。

#### 1. 两参数（最常用，结果类型同输入类型）

```java
T reduce(T identity, BinaryOperator<T> accumulator);
```

- **用途**：如求和。初始值是 int，累加也得到 int。
- **格式**：`(T 初始值, (当前总和, 新元素) -> 新总和)`
- `stream.reduce(0, (acc, x) -> acc + x)`

#### 2. 单参数（返回 Optional）

```java
Optional<T> reduce(BinaryOperator<T> accumulator);
```

- **用途**：没有初始值。比如求最大值（流如果是空的，就没有最大值，所以返回 Optional）。
- **格式**：`((当前结果, 新元素) -> 新结果)`

#### 3. 三参数（最复杂，结果类型可不同）—— 你例子里用的就是这个

```java
<U> U reduce(U identity,
             BiFunction<U, ? super T, U> accumulator,
             BinaryOperator<U> combiner);
```

这正是你例子中的写法：

- **`identity` (初始值)**：`new StringCombiner(...)`
  - 这里你给了一个全新的对象 `StringCombiner` 作为起步。
- **`accumulator` (累加器)**：`StringCombiner::add`
  - **格式**：`(U result, T element) -> U`
  - **解释**：怎么把流里的一个新元素（`Artist` 名字）塞进你的 `StringCombiner` 里？调用 `add` 方法。
- **`combiner` (组合器)**：`StringCombiner::merge`
  - **格式**：`(U result1, U result2) -> U`
  - **解释**：**如果流是并行执行的**（多线程），线程 A 算出来一个 `StringCombiner`，线程 B 也算出来一个。最后怎么把这两个 `StringCombiner` 合并成一个？调用 `merge` 方法。

**总结你的例子：**
你在这个例子里，实际上是用 `reduce` 硬生生模仿了 `collect` 的行为（因为 `collect` 才是专门用来做 mutable reduction 的，而 `reduce` 本意是做 immutable reduction 的）。
作者展示这段代码主要是为了说明：**别这么写！太麻烦了！请直接用 `collect` 和定制的 `Collector`。**

### 5.3.8 收集器的特征 (Collector Characteristics)

也就是 `Collector.Characteristics` 枚举，它相当于给收集器贴的“标签”。
Stream 框架看到这些标签，就知道可以进行哪些优化。

> 简单来说，特征 (Characteristics) 是你写收集器时给 Stream 框架的 “优化建议” 或者说 “免责声明”。

主要有这三个标签：

#### 1. IDENTITY_FINISH (恒等终结)

- **意思**：告诉框架，“我的容器就是最终结果，不需要额外转换”。
- **例子**：`Collectors.toList()`。累加完了得到一个 List，这本身就是我要的，不需要再对这个 List 做什么处理。
- **反例**：`Collectors.joining()`。它的容器可能是 `StringBuilder`，但最终结果需要是 `String`。所以它**不是** IDENTITY_FINISH，必须在最后调用 `toString()` 把 StringBuilder 变成 String。

#### 2. UNORDERED (无序)

- **意思**：告诉框架，“我在乎的只是结果里有哪些元素，我不关心它们的顺序”。
- **例子**：`Collectors.toSet()`。Set 本身就是无序的。
- **优化**：如果 Stream 是并行的，框架就不需要费劲去保证合并后的顺序和原始流一样了，怎么快怎么来。

#### 3. CONCURRENT (并发)

- **意思**：告诉框架，“我的这个容器是线程安全的（比如 `ConcurrentHashMap`），你可以让多个线程**同时**直接往这**同一个**容器里塞数据，而不需要像传统并行流那样‘每个线程搞一个分容器，最后再合并’”。
- **例子**：`Collectors.toConcurrentMap()`。
- **区别**：
  - **普通并行**：每个线程自己造个小 List，填满后，主线程再把这堆小 List 合并成大 List（`combine` 方法）。
  - **CONCURRENT 并行**：大家共用一个线程安全的 Map，谁算出来谁直接塞进去。省去了最后的“合并”步骤，性能极高。

**总结：**
这些特征就像是给 Stream 框架的“优化提示卡”。
如果你自定义收集器时不声明这些特征，框架就会采用最保守（最安全但可能最慢）的策略执行。

### 5.3.9 核心疑惑：Stream.reduce 和 Collectors.reducing 的区别

> "我们之前不是也在用 reducing (其实是 reduce) 吗？为什么这次参数又不匹配了？"

这是一个命名陷阱。虽然名字很像，参数个数也经常一样（都是 3 个），但在**第二个参数**的定义上，它们是**截然不同**的。

| 方法                  | 第 2 个参数的作用        | 参数类型               | StringCombiner::add 能用吗？ |
| :-------------------- | :----------------------- | :--------------------- | :--------------------------- |
| `Stream.reduce`       | **Accumulator (累加器)** | `(结果, 元素) -> 结果` | ✅ **能** (符合 Accumulator) |
| `Collectors.reducing` | **Mapper (转换器)**      | `(元素) -> 结果`       | ❌ **不能** (不符合 Mapper)  |

- **Stream.reduce** 是“一边遍历一边累加”。它拿着现有的容器，把新元素 `add` 进去。
- **Collectors.reducing** 是标准的 **Map-Reduce** 模型。它要求你先把每个新元素 `Map` (转换) 成一个独立的结果对象，然后再把这些结果对象 `Reduce` (合并) 起来。

所以：

- 在 `stream.reduce` 里，`add` 是动作，把元素加到容器里。
- 在 `collect(reducing)` 里，中间那个参数必须是“转换动作”，`add` 显然不是转换动作（它是把元素塞进`this`的动作）。

**结论**：这就是为什么作者说“感到恶心”且“低效”。对于可变聚合（Mutable Reduction），请永远使用 `collect` 配合 `Collector.of` 或自定义收集器，不要试图用 `reducing`（它是为不可变归约设计的）来强行套用可变容器。

> 你有一万个字符串，这段代码就会创建 一万个 临时的 StringCombiner 对象，仅仅是为了把字符串包一下传给 merge，然后马上扔掉。

### 7.1.1 案例分析：Logger 的重构

这段文字核心是在讲如何利用 Lambda 表达式来实现 **“延迟执行” (Lazy Evaluation)** 和 **“更好的封装”**。

他所说的“好的”方式，指的就是 **例 7-2** 这种写法：

```java
logger.debug(() -> "Look at this: " + expensiveOperation());
```

**为什么说它好？好在哪里？**

要理解这个，我们需要对比三种情况：

1. 最笨的写法（性能差）

   ```java
   // ❌ 即使 debug 没开启，expensiveOperation() 也会被执行！
   logger.debug("Look at this: " + expensiveOperation());
   ```

   - **问题**：Java 在调用方法前会先计算参数。字符串拼接和 `expensiveOperation()` 会先执行，哪怕最后 Logger 发现现在的级别是 INFO，根本不需要打印这条 DEBUG 日志，刚才的计算资源也白费了。

2. 传统的优化写法（代码啰嗦，破坏封装）—— 例 7-1

   ```java
   // ⚠️ 为了避免上面的性能浪费，我们不得不加个 if
   if (logger.isDebugEnabled()) {
       logger.debug("Look at this: " + expensiveOperation());
   }
   ```

   - **好处**：确实避免了不必要的计算。
   - **坏处（作者批评的点）**：
     - **啰嗦**：每打印一条日志都要写个 `if`，代码里充斥着这种判断逻辑。
     - **破坏封装**：外部代码不应该去关心 Logger 的内部状态（是否开启了 Debug）。“检查是否开启”这个逻辑应该由 Logger 自己在内部判断，而不是让使用者在外面判断。

3. Lambda 写法（即“好的写法”）—— 例 7-2

   ```java
   // ✅ 既简洁，又高性能，封装也完美
   logger.debug(() -> "Look at this: " + expensiveOperation());
   ```

   这里传给 `debug` 方法的 **不再是一个计算好的字符串结果，而是一个 Lambda 表达式（这就好比传了一个“产生结果的方法/配方”）**。

   - **真正的执行逻辑（在 Logger 内部）**：
     Logger 类的 `debug` 方法内部大概是这样写的：

     ```java
     public void debug(Supplier<String> messageSupplier) {
         if (this.isDebugEnabled()) { // 内部自己检查
             // 只有检查通过了，才去调用 get()，由 Lambda 此时才真正执行 expensiveOperation()
             String message = messageSupplier.get();
             System.out.println(message);
         }
     }
     ```

**总结**：

作者并没有说 `logger.isDebugEnabled()` 这个**判断行为**本身不好，而是说**由调用者（你）在外面手动写这个判断**不好。

“好的方式”是：**你只需要把这句代码打包成一个 Lambda 扔进去，什么时候执行、要不要执行，全权交给 Logger 内部去决定。** 这样你就只要写一行代码，既省事，性能又好（因为不需要打印时 Lambda 根本不会被执行）。

> Q：2 和 3 没有本质区别吗？同样是每次打印日志都有 if 判断，只不过隐藏起来了

你说得非常敏锐。从 **CPU 执行指令** 的角度来看，你完全正确：**`if` 判断并没有消失，它只是挪了位置**。

但是，在 **软件设计（架构和编程思想）** 的层面上，这两者有本质的区别。作者所推崇的“好”，主要体现在以下三个方面：

1. 核心区别：封装 (Encapsulation) —— "Tell, Don't Ask" 原则

   - **写法 2 (你的写法)**：`if (logger.isDebugEnabled()) ...`
     - 这叫 **"Ask"**（询问）。你在不断地问 Logger：“嘿，你现在开启 Debug 了吗？”如果开了，你再把数据给它。
     - **坏处**：这暴露了 Logger 的内部状态。调用者不得不关心“日志级别”这个概念。如果哪天 Logger 的判断逻辑变复杂了（比如除了看级别，还要看当前是哪个用户），你所有写了 `if` 的地方都可能要改。
   - **写法 3 (Lambda 写法)**：`logger.debug(() -> ...)`
     - 这叫 **"Tell"**（告知）。你只是告诉 Logger：“这是生成日志的方法。” 至于怎么判断、什么时候打印、要不要打印，那是 Logger 自己的私事。
     - **好处**：调用者完全不需要知道 Logger 内部是如何工作的。逻辑被完美地**封装**在 Logger 类内部了。

2. 代码的可维护性 (Maintainability)

   想象一下，如果你在一个大项目里有 1000 个地方打印日志。

   - **写法 2**：你的代码里散布着 1000 个 `if (logger.isDebugEnabled())`。这不仅让代码显得臃肿（Noise），而且如果以后想把全局的日志开关改成“根据配置文件动态热加载”，你虽然不用改 `if`，但如果你想改成“特定模块才判断”，代码就会很难看。
   - **写法 3**：你的代码里只有清爽的 `logger.debug(...)`。所有的判断逻辑都收敛在 `Logger` 类的那 **一个** `debug` 方法里。想改规则？改那一个地方就够了。

3. “代码即数据” 的思维转变

   作者提到“传入代码即数据”。

   - 在写法 2 中，我们习惯于**先准备好数据**（或者先判断能不能准备数据），再传给方法。
   - 在写法 3 中，我们传递的是**“行为”**（Lambda 表达式）。我们不再传递一个死板的字符串，而是传递了一个**“产生字符串的能力”**。这让 Logger 拥有了更高的控制权（Control Inversion）。

**总结**：

你说得对，**物理上的 `if` 确实只是被隐藏了，并没有消失**（能量守恒嘛，逻辑总是要执行的）。

但这个“隐藏”动作本身就是 **面向对象设计的核心**——把脏活累活藏在类内部，留给外部一个干净、高抽象的接口。**程序员追求的“高效”往往不只是运行速度，更是代码的整洁和可维护性。**

### 8.1 单例成为反模式

这段话其实是在讲技术圈的一个经典现象：**“风水轮流转，没有银弹”**。

具体到他提到的几个概念（单例模式、敏捷开发、测试、反模式），逻辑关系是这样的：

1. 曾经的宠儿：单例模式 (Singleton Pattern)

   - **以前 (比如 10-20 年前)**：大家觉得单例模式特好。
     - **为什么？** 因为它保证全局只有一个实例（比如一个 `DatabaseConnection`），省资源，而且随时随地用 `Sinceleton.getInstance()` 就能拿到，特方便。

2. 时代的变迁：敏捷开发 (Agile) 与 测试

   - **后来**：敏捷开发火了。敏捷开发非常强调**自动化测试（特别是单元测试）**。
     - **冲突爆发了**：当大家试图给使用了单例模式的代码写单元测试时，发现简直是噩梦。

3. 为什么单例难测试？（核心矛盾）

   - **全局状态 (Global State)**：单例就像一个全局变量。
     - **测试 A** 改了单例里的数据。
     - **测试 B** 跑的时候，发现数据怎么不对劲？原来是被测试 A 污染了。
     - 为了跑测试 B，你得先把单例“洗干净”（Reset），但这很难，因为单例设计初衷就是为了“一直存在”。
   - **强耦合 (Tight Coupling)**：
     - 如果在业务代码里直接写死了 `Database.getInstance().save()`。
     - 你想测业务代码，但不想真的连数据库，你想换个“假数据库”？**换不了**。因为代码里写死调用那个真单例了，没法注入替身（Mock）。

4. 结论：变成了“反模式 (Anti-pattern)”

   - 因为单例让代码变得**“脆弱”**（测试之间互相干扰）且**“难于测试”**（没法替换），在现在这个重视测试的时代，它就从“最佳实践”变成了人人喊打的“反模式”。

这段话的深层含义

作者举这个例子的目的是为了给后面铺垫或者是发出警告：

> **“别把我现在教你的 Lambda 技巧当成真理。技术是服务于场景的。就像单例模式当年也是好东西，如果在不合适的场景（比如强依靠测试的场景）用，好东西也会变成坏东西。”**

简而言之：**以前大家不论什么情况都爱用单例，后来发现它害得测试没法写，所以现在大家不推荐用了。**

Q：单元测试前后设置状态，比如 beforetest 或者用模拟不是很正常吗？这些都足以应对？

你说得很有道理，技术上确实 **“能”** 做到，但问题的关键在于 **“代价”** 和 **“设计健康度”**。

在单例模式下，`@Before` 重置状态和 Mock 模拟主要面临以下三个巨大的**痛点**，正是这些痛点让它被视为“反模式”：

1. 难以 Mock（这是最大的硬伤）

   标准的 Mock 框架（如 Mockito）是基于**对象实例**和**接口**工作的。

   - **依赖注入 (DI) 的代码**：

     ```java
     // 构造函数明确要一个 Database 对象
     public Service(Database db) { this.db = db; }
     ```

     测试时，你直接 `new Service(mock(Database.class))` 就行了。很轻松。

   - **单例的代码**：

     ```java
     public void doSomething() {
         //代码里写死了调用静态方法
         Singleton.getInstance().process();
     }
     ```

     当你测试 `doSomething` 时，代码直接跳转到 `Singleton.getInstance()` 的真实逻辑里去了。

     - **普通的 Mockito 拦截不了静态方法**。
     - 为了 Mock 它，你必须引入像 **PowerMock** 这样“重型”的工具，去修改字节码。这会导致测试运行变慢，且更容易出奇奇怪怪的 Bug。

2. 并行测试的噩梦 (Parallel Execution)

   现代 CI/CD 流程为了快，通常会 **多线程并行运行** 单元测试。

   - 如果你的单例持有状态（比如 `count`）。
   - **线程 A（测试 1）** 正在把 `count` 设为 10。
   - **线程 B（测试 2）** 刚把 `count` 重置为 0。
   - 只要这两个测试同时跑，它们就会互相改写同一个内存地址的数据。**`@Before` 在这里救不了你**，因为这是并发竞争。
   - 结果就是：测试在这个机器上能过，在那个机器上挂，或者偶尔挂（Flaky Tests）。这是开发者最痛恨的事情。

3. API 撒谎 (Hiding Dependencies)

   如果我给你一个类：

   ```java
   public class UserManager {
       // 构造函数是空的
       public UserManager() {}
   }
   ```

   你看这个 API，会以为它是一个很单纯的类，不需要任何外部依赖。
   结果你一运行测试：**报错！连接数据库失败！**
   你一脸懵逼：它可以直接 `new` 出来啊？

   去读源码才发现，它在某个深层方法的角落里偷偷调用了 `DatabaseConnection.getInstance()`。

   - **单例模式隐藏了依赖关系**。
   - **依赖注入** 则会把依赖显式写在构造函数里，让你一眼就看出：**“要想测这个类，必须先给我一个 Database。”**

总结

你说得对，靠 `setUp/tearDown` 和反射暴力重置，确实**能**测。
但就像是：**“我用一把瑞士军刀也能砍倒大树，为什么非要说电锯才是最好的？”**

单例模式让原本顺滑的测试流程变得必须“小心翼翼”（手动清理状态、必须串行跑、必须用重型 Mock 工具）。在敏捷开发这种**“测试是呼吸”**的节奏下，任何增加测试摩擦力的设计，都会被贴上“反模式”的标签。

### 8.2 环绕执行模式 (Execute Around Pattern) 的利弊

**“拆分”既是好的，也是“危险”的，取决于你的使用场景。**

这种写法被很多资深 Java 开发者称为“代码体操”（Mental Gymnastics），看似复杂，实则是一种取舍。

> 在软件工程的语境下，"Mental Gymnastics"（思维体操 / 代码体操）通常是贬义 (Derogatory) 的，或者至少是带有调侃和无奈意味的。
> 它指的不是“锻炼大脑有益健康”，而是指**“为了理解这段代码，我的大脑不得不做高难度的翻滚动作，太累了”**。
> 在《Effective Java》和 Clean Code 倡导的价值观里，代码应该是“平铺直叙”的。如果别人评价你的代码是 "Mental Gymnastics"，这通常不是夸奖，而是在委婉地建议你：“Keep It Simple, Stupid (KISS)”。

#### 1. 为什么说它是“好的”？（为了复用“流程”）

试想一下，如果你不这么拆分，而是在一个大项目里有 10 个地方需要处理文件。

- **地方 A**：读文件，找标题。
- **地方 B**：读文件，统计字数。
- **地方 C**：读文件，计算哈希值。

如果你不把 `withLinesOf` 提炼出来，你那 10 个地方的代码都会长这样：

```java
try (BufferedReader reader = new BufferedReader(input)) {
    // ... 这里是业务逻辑 ...
} catch (IOException e) {
    throw new CustomException(e);
}
```

你会发现：**开启资源、关闭资源、异常转译（catch IOException throw RuntimeException）** 这三件事，你重复写了 10 遍。

**`withLinesOf` 的价值在于：它把“资源管理的脏活累活”给封装了。**
业务逻辑 `findHeadings` 变得无比清爽，只关心“我要怎么处理这些行”，而不用关心“文件怎么开、怎么关、报错了怎么办”。

#### 2. 为什么说它“没那么好”？（认知负担）

正如你所感叹的“代码有点抽象”，这就是代价。

- **阅读阻碍**：以前你读代码是顺着往下读。现在你读到 `withLinesOf`，脑子得“跳”一下：“等会，这个方法去哪了？哦，下面。它又接了个 lambda？这个 lambda 什么时候执行？”
- **过度设计**：如果你这个项目里，**只有这一个地方**需要读文件，那搞这么大阵仗（定义泛型 T，传入两个 Function）绝对是 **过度设计 (Over-engineering)**。直接写个 `try-catch` 也就是 5 行代码的事，比这个“高阶函数”简单多了。

#### 总结

- **如果是写框架/工具类**（比如 Spring 的 `JdbcTemplate`），或者你有 **大量** 类似的资源操作，这种写法是 **极好** 的（DRY 原则）。
- **如果是写业务一次性逻辑**，并且没有复用需求，这种写法是 **不好** 的（增加了不必要的复杂性）。

### 8.2.1 补充：它和回调 (Callback) 有什么区别？

**本质上，它们确实都是回调（Callback）。** 但在 Java 的语境下，我们通常把它们区分开来，主要是因为**用途（Intent）**和**执行时机（Timing）**不同：

#### 1. 这里的 Lambda (环绕执行模式 / 同步回调)

- **本质**：**同步回调 (Synchronous Callback)**
- **场景**：资源管理、事务处理、锁管理。
- **比喻**：你去银行办业务。
  - 银行经理（`withLinesOf` 方法）对你说：“你把身份证和填好的单子给我，我进去帮你盖个章，你**站在这别动**，盖完我马上给你。”
  - **关键点**：你是**等**在那里的。虽然是你把“单子”（Lambda）交给了经理，但整个过程是**在一个线程里串行执行**的。调用者必须等待 `withLinesOf` 返回。
  - **目的**：为了复用“进门刷卡、出门签字”这一套死板的流程。

#### 2. 你印象中的“回调” (异步 IO / JS 风格)

- **本质**：**异步回调 (Asynchronous Callback)**
- **场景**：网络请求、GUI 事件响应、耗时计算。
- **比喻**：你在网上买了东西。
  - 快递员对你说：“货到了我给你打电话（执行回调），你现在该干嘛干嘛去，**不用等**。”
  - **关键点**：你**不等**。主线程继续往下跑，等 IO 真的读完了，操作系统或者另一个线程会把你的 Lambda 拿出来执行。
  - **目的**：为了**非阻塞**，为了性能（Node.js 或 Netty 的核心思想）。

#### 3. 总结 (Callback)

**一句话区别：** 这里的 Lambda 是为了**“借用”**（借用外层的 try-finally 壳子），而通常说的 IO 回调是为了**“解耦”**（时间和执行流上的解耦）。
