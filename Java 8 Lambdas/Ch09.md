# 第 9 章 使用 Lambda 表达式编写并发程序（讨论并发，怎样使用 Lambda 表达式写出易读且易于维护的并发代码）

## 9.1 为什么要使用非阻塞式 I/O

**阻塞式 I/O**缺点是， 将系统扩展至支持大量用户时， 需要和服务器建立大量 TCP 连接， 因此扩展性不是很好。

**非阻塞式 I/O**， 有时也叫**异步 I/O**和阻塞式 I/O 不同， 对聊天程序客户端的读写调用立即返回， 真正的读写操作则在另一个独立的线程执行， 这样就可以同时执行其他任务了。

然而这种方式压根儿就没有在 Java 程序员中流行起来， 它编写出来的代码难于理解和调试。

## 9.4 末日金字塔

读者已经看到了如何使用回调和事件编写非阻塞的并发代码， 但是我还没提起房间里的大象。 **如果编写代码时使用了大量的回调， 代码会变得难于阅读， 即便使用了 Lambda 表达式也是如此。**

我已经将建立连接的通用代码重构， 即使这样， 读者依然会注意到那些嵌套的回调形成了一个末日金字塔。 代码不断地向屏幕右方挤过去， 就像一座金字塔。这是一个众所周知的反模式， 让代码难于阅读和理解。

重构将测试逻辑分散在了多个方法里， 解决了末日金字塔问题。 不再是一个方法只能有一个功能， 我们将一个功能分散在了多个方法里！ 代码还是难于阅读， 不过这次换了一个方式。

> 可以看一下书里的代码，没必要复制到这里。

## 9.5 Future

构建复杂并行操作的另外一种方案是使用 Future。 **Future 像一张欠条， 方法不是返回一个值，而是返回一个 Future 对象， 该对象第一次创建时没有值， 但以后能拿它“换回” 一个值。**

调用 Future 对象的 get 方法获取值， 它会阻塞当前线程， 直到返回值。

如果要将 Future 对象的结果传给其他任务， 会阻塞当前线程的执行。 这会成为一个性能问题， 任务不是平行执行了， 而是（意外地） 串行执行。

我们真正需要的是不必调用 get 方法阻塞当前线程， 就能操作 Future 对象返回的结果。 我们需要将 Future 和回调结合起来使用。

## 9.6 CompletableFuture

这些问题的解决之道是 CompletableFuture， 它结合了 Future 对象打欠条的主意和使用回调处理事件驱动的任务。 其要点是可以组合不同的实例， 而不用担心末日金字塔问题。

> 你以前可能接触过 CompletableFuture 对象背后的概念， 在其他语言中这被叫作延迟对象或约定（Promise）。 在 Google Guava 类库和 Spring 框架中， 这被叫作 ListenableFutures。

CompletableFuture API 的技巧是注册 Lambda 表达式， 并且把高阶函数链接起来。 方法不同， 但道理和 Stream API 的设计是相通的。

CompletableFuture 对象包含 join 方法， 我们在 ➍ 处调用了该方法， 它的作用和 get 方法是一样的， 而且它没有使用 get 方法时令人倒胃口的检查异常。

创建 CompletableFuture 对象分两部分： 创建对象和传给它欠客户代码的值。

CompletableFuture 的常用情境之一是异步执行一段代码， 该段代码计算并返回一个值。

```java
// 异步创建 CompletableFuture 实例的示例代码
CompletableFuture<Track> lookupTrack(String id) {
    return CompletableFuture.supplyAsync(() -> {
        // 这里会做一些繁重的工作， 同时不会阻塞当前线程
        // ...
        return track;
        // Executor， 告诉 CompletableFuture 对象在哪里执行任务
        // 如果没有提供 Executor， 就会使用相同的 fork/join 线程池并行执行。
    }, service);
}
```

CompletableFuture 为此提供了 completeExceptionally， 用于处理异常情况。

```java
future.completeExceptionally(new AlbumLookupException("Unable to find " + name));
```

让我们简单看一下其中的一些用例。

- 如果你想在链的末端执行一些代码而不返回任何值， 比如 Consumer 和 Runnable， 那就看看 thenAccept 和 thenRun 方法。
- 可使用 thenApply 方法转换 CompletableFuture 对象的值， 有点像使用 Stream 的 map 方法。
- 在 CompletableFuture 对象出现异常时， 可使用 exceptionally 方法恢复， 可以将一个函数注册到该方法， 返回一个替代值。
- 如果你想有一个 map， 包含异常情况和正常情况， 请使用 handle 方法。
- 要找出 CompletableFuture 对象到底出了什么问题， 可使用 isDone 和 isCompletedExceptionally 方法辅助调查。

## 9.7 响应式编程

CompletableFuture 背后的概念可以从单一的返回值推广到数据流， 这就是**响应式编程**。 响应式编程其实是一种声明式编程方法， 它让程序员以自动流动的变化和数据流来编程。

> 这部分也可以看《Java 8 实战》

RxJava 类库引入了一个叫作 Observable 的类， 该类代表了一组待响应的事件， 可以理解为一沓欠条。 在 Observable 对象和第 3 章讲述的 Stream 接口之间有很强的关联。

最大的不同在于用例。 Stream 是为构建内存中集合的计算流程而设计的， 而 **RxJava 则是为了组合异步和基于事件的系统流程而设计的**。 它没有取数据， 而是把数据放进去。 换个角度理解 RxJava， 它是处理一组值， 而 CompletableFuture 用来处理一个值。

```java
// 通过名字和国籍查找艺术家
// 它在本地缓存了一份艺术家名单， 但必须从外部服务上查询艺术家信息
public Observable<Artist> search(String searchedName,
                                 String searchedNationality,
                                 int maxResults) {
    // 取得一个包含艺术家姓名的 Observable 对象
    return getSavedArtists()
        .filter(name -> name.contains(searchedName))
        .flatMap(this::lookupArtist)
        .filter(artist -> artist.getNationality()
                .contains(searchedNationality))
        .take(maxResults);
}
```

这个 API 很像使用 Stream。 它和 Stream 的最大区别是： Stream 是为了计算最终结果， 而 RxJava 在线程模型上则像 CompletableFuture。

> 读者如果想了解跟多细节， 请阅读项目文档（https://github.com/ReactiveX/RxJava/wiki/Getting-Started）。 RxJava 已经开始集成进 Java 类库的生态系统， 比如企业级 的 集 成 框 架 Apache Camel 已 经 加 入 了 一 个 叫 作 Camel RX（http://camel.apache.org/rx.html） 的模块， 该模块使得可以在该框架中使用 RxJava。 Vert.x 项目也启动了一个 Rxify（https://github.com/vert-x/mod-rxvertx） 它的 API 项目。

## 9.8 何时何地使用新技术

事件驱动和响应式应用正在变得越来越流行， 而且经常会是为你的问题建模的最好方式之一。 响应式编程宣言（http://www.reactivemanifesto.org/） 鼓励大家使用这种方式编写更多应用， 如果它适合你的待解问题， 那么就应该使用。 相比阻塞式设计， 有两种情况可能特别适合使用响应式或事件驱动的方式来思考。

- 第一种情况是业务逻辑本身就使用事件来描述。（Twitter）

- 另一种显然的用例是应用需要同时处理大量 I/O 操作。（阻塞式 I/O）

> 不是大家不用，也许和日常业务代码的场景要和这些建立联系很难，另外提到之前的防御式编程，有人认为这种技术大部分基础开发人员本身也不怎么会。

## 9.9 要点回顾

- 使用基于 Lambda 表达式的回调， 很容易实现事件驱动架构。
- CompletableFuture 代表了 IOU， 使用 Lambda 表达式能方便地组合、 合并。
- Observable 继承了 CompletableFuture 的概念， 用来处理数据流。
