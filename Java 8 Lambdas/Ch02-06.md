# JDK 8 中核心语言的变化以及升级后的类库

## 第 2 章 Lambda 表达式

在引入 lambda 之前，大家用的都是匿名内部类。这实际上是一个代码即数据的例子（行为参数化），传递的是一个代表某种行为的对象（毕竟还是要 new 的）。

不过这样还是很冗繁，样板代码并不是唯一的问题：这些代码还相当难读，因为它没有清楚地表达程序员的意图。**我们不想传入对象，只想传入行为。**

```java
button.addActionListener(new ActionListener() {
    // 实际上lambda只要能匹配上，都算有名字
    public void actionPerformed(ActionEvent event) {
    System.out.println("button clicked");
    }
});

// 1. 传入的是一个没有名字的函数
// 2. 而在 Lambda 表达式中无需指定event类型（根据上下文（addActionListener 方法的签名） 在后台推断）
button.addActionListener(event -> System.out.println("button clicked"));
```

Lambda 表达式除了基本的形式之外， 还有几种变体

```java
// 不包含参数， 使用空括号 () 表示没有参数
Runnable noArguments = () -> System.out.println("Hello World");
// 包含且只包含一个参数， 可省略参数的括号
ActionListener oneArgument = event -> System.out.println("button clicked");
// 一段代码块， 使用大括号（{}）将代码块括起来,可以用返回或抛出异常来退出
Runnable multiStatement = () -> {
    System.out.print("Hello");
 System.out.println(" World");
};
// 表示包含多个参数的方法
BinaryOperator<Long> add = (x, y) -> x + y;
// 有时最好也可以显式声明参数类型， 此时就需要使用小括号将参数括起来
BinaryOperator<Long> addExplicit = (Long x, Long y) -> x + y;
```

**目标类型**是指 Lambda 表达式所在上下文环境的类型。

上述例子还隐含了另外一层意思： **Lambda 表达式的类型依赖于上下文环境， 是由编译器推断出来的**。 目标类型也不是一个全新的概念。 一个常见的例子是 null， 只有将 null 赋值给一个变量， 才能知道它的类型。

### 2.1 引用值， 而不是变量

使用匿名内部类时：如果需要引用它所在方法里的变量，**需要将变量声明为 final**。

> 将变量声明为 final，意味着不能为其重复赋值。同时也意味着在使用 final 变量时，实际上是在使用赋给该变量的一个特定的值。

Java 8 虽然放松了这一限制， 可以引用非 final 变量， 但是该变量在**既成事实上**必须是 final。 虽然无需将变量声明为 final， 但在 Lambda 表达式中， 也无法用作非终态变量。 如果坚持用作非终态变量， 编译器就会报错。

> 换句话说， Lambda 表达式引用的是值，而不是变量。
>
> 不过 final 就像代码中的线路噪声， 省去之后代码更易读。

这种行为也解释了为什么 Lambda 表达式也被称为**闭包**。未赋值的变量与周边环境隔离起来，进而被绑定到一个特定的值。无论名字如何，如前文所述，Lambda 表达式都是静态类型的。

> 在众说纷纭的计算机编程语言圈子里，Java 是否拥有真正的闭包一直备受争议，因为在 Java 中只能引用既成事实上的 final 变量。名字虽异，功能相同。

### 2.2 Lambda 表达式本身的类型： 函数接口

**函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的类型。**

在 Java 里，所有方法参数都有固定的类型。使用只有一个方法的接口来表示某特定方法并反复使用，是很早就有的习惯。Lambda 表达式也使用同样的技巧，并将这种接口称为**函数接口**。

```java
public interface ActionListener extends EventListener {
    // 被用来表示行为
    public void actionPerformed(ActionEvent event);
}
```

这就是函数接口，接口中单一方法的命名并不重要，只要方法签名和 Lambda 表达式的类型匹配即可。可在函数接口中为参数起一个有意义的名字增加代码易读性，便于更透彻地理解参数的用途。

> 毕竟实际用的时候都是匿名函数（实际是有名字的），基本不用关心叫什么名字。

Java 中重要的函数接口

| 接口                | 参数   | 返回类型 | 示例                   |
| :------------------ | :----- | :------- | :--------------------- |
| `Predicate<T>`      | T      | boolean  | 这张唱片已经发行了吗   |
| `Consumer<T>`       | T      | void     | 输出一个值             |
| `Function<T,R>`     | T      | R        | 获得 Artist 对象的名字 |
| `Supplier<T>`       | None   | T        | 工厂方法               |
| `UnaryOperator<T>`  | T      | T        | 逻辑非（`!`）          |
| `BinaryOperator<T>` | (T, T) | T        | 求两个数的乘积（`*`）  |

### 2.3 类型推断

Lambda 表达式中的类型推断，实际上是 Java 7 就引入的目标类型推断的扩展。Java 7 中的菱形操作符，它可使 javac 推断出泛型参数的类型。如果将构造函数直接传递给一个方法，也可根据方法签名来推断类型。Java 8 更进一步，程序员可省略 Lambda 表达式中的所有参数类型。

类型推断系统相当智能，但若信息不够，类型推断系统也无能为力。类型系统不会漫无边际地瞎猜，而会中止操作并报告编译错误，寻求帮助。

### 2.4 要点回顾

- Lambda 表达式是一个匿名方法，将行为像数据一样进行传递。（行为参数化）
- Lambda 表达式的常见结构：`BinaryOperator<Integer> add = (x, y) → x + y`。
- 函数接口指仅具有单个抽象方法的接口，用来表示 Lambda 表达式的类型。

## 第 3 章 流

本章涉及到 Java 对核心类库的改进，对核心类库的改进主要包括集合类的 API 和新引入的流（Stream）。流使程序员得以站在更高的抽象层次上对集合进行操作。

### 3.1 从外部迭代到内部迭代

之前想要迭代循环只能用 for 循环，一个通用的模式是在集合上进行迭代，然后处理返回的每一个元素。

缺点：

- 每次迭代集合类时， 都需要写很多样板代码
- 无法流畅传达程序员的意图（尤其是嵌套循环）

> 当大家都觉得某某是样板代码或者写起来没有必要的时候说明就是，也是时候优化语法了

for-each 循环其实是一个封装了迭代的语法糖，首先调用 iterator 方法，产生一个新的 Iterator 对象，进而控制整个迭代过程， 这就是**外部迭代**。

外部迭代也有问题。首先，它很难抽象出本章稍后提及的不同操作；此外，它从本质上来讲是一种串行化操作。 总体来看， **使用 for 循环会将行为和方法混为一谈**。

内部迭代就如使用 stream() 方法的调用一样，方法不是返回一个控制迭代的 Iterator 对象，而是返回内部迭代中的相应接口：Stream。**Stream 是用函数式编程方式在集合类上进行复杂操作的工具。**由于 Stream API 的函数式编程风格，我们并没有改变集合的内容，而是描述出 Stream 里的内容。

<img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch03-image-20251219231521332" alt="image-20251219231521332" style="zoom: 50%;" /> <img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch03-image-20251219231544887" alt="image-20251219231544887" style="zoom: 50%;" />

外部迭代与内部迭代

### 3.2 实现机制

类库设计精妙，只需对列表迭代一次。

> 类似于流水线，虽然有多个环节，但是运行起来只有一条，每个环节都是这条流水线的一部分。

Stream 的两种方法：

- **惰性求值方法**：像 filter 这样只描述 Stream， 最终不产生新集合的方法
- **及早求值方法**：像 count 这样最终会从 Stream 产生值的方法

判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。如果**返回值是 Stream**，那么是惰性求值；如果**返回值是另一个值或为空**，那么就是及早求值。

整个过程和**建造者模式**有共通之处。建造者模式使用一系列操作设置属性和配置，最后调用一个 build 方法， 这时，对象才被真正创建。

> 如果没有及早求值方法，则这个流就不会实际运行（运行了也没结果所以不用运行）。

### 3.3 常用的流操作

#### 3.3.1 `collect(toList())`

收集器：`collect(toList())` 方法由 Stream 里的值生成一个列表，是一个及早求值操作。

#### 3.3.2 map

如果有一个函数可以将一种类型的值转换成另外一种类型，map 操作就可以使用该函数，将一个流中的值转换成一个新的流。

#### 3.3.3 filter

遍历数据并检查其中的元素时，可尝试使用 Stream 中提供的新方法 filter。

#### 3.3.4 flatMap

flatMap 方法可用 Stream 替换值，然后将多个 Stream 连接成一个 Stream。

#### 3.3.5 max 和 min

Stream 上常用的操作之一是求最大值和最小值。Stream API 中的 max 和 min 操作足以解决这一问题。

#### 3.3.7 reduce

reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count、min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。

图 3-8 展示了如何通过 reduce 操作对 Stream 中的数字求和。以 0 作起点——一个空 Stream 的求和结果，每一步都将 Stream 中的元素累加至 accumulator，遍历至 Stream 中的最后一个元素时，accumulator 的值就是所有元素的和。

<img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch03-image-20251222185534845" alt="image-20251222185534845" style="zoom:50%;" />

图 3-8：使用 reduce 操作实现累加

#### 3.3.8 整合操作

现在或许是个思考的好机会，你真的需要对外暴露一个 List 或 Set 对象吗？可能一个 Stream 工厂才是更好的选择。 **通过 Stream 暴露集合的最大优点在于，它很好地封装了内部实现的数据结构。仅暴露一个 Stream 接口， 用户在实际操作中无论如何使用，都不会影响内部的 List 或 Set。**

同时这也鼓励用户在编程中使用更现代的 Java 8 风格。**不必一蹴而就，可以对已有代码渐进性地重构，保留原有的取值函数，添加返回 Stream 对象的函数，时间长了，就可以删掉所有返回 List 或 Set 的取值函数。**清理了所有遗留代码之后，这种重构方式让人感觉棒极了！

### 3.4 重构遗留代码

事实上，对 Stream API 越熟悉，就越不需要细分步骤。

简而言之，选取一段遗留代码进行重构，转换成使用流风格的代码。最初只是简单地使用流，但没有引入任何有用的流操作。随后通过一系列重构，最终使代码更符合使用流的风格。在上述步骤中我们没有提到一个重点，即编写示例代码的每一步都要进行单元测试，保证代码能够正常工作。重构遗留代码时，这样做很有帮助。

### 3.5 多次调用流操作

用户也可以选择每一步强制对函数求值 而不是将所有的方法调用链接在一起，但是，最好不要如此操作。

例 3-24 所示代码和流的链式调用相比有如下缺点：

- 代码可读性差， 样板代码太多， 隐藏了真正的业务逻辑；
- 效率差， 每一步都要对流及早求值， 生成新的集合；
- 代码充斥一堆垃圾变量， 它们只用来保存中间结果， 除此之外毫无用处；
- 难于自动并行化处理。

当然，刚开始写基于流的程序时，这样的情况在所难免。但是如果发现自己经常写出这样的代码，就要反思能否将代码重构得更加简洁易读。

### 3.6 高阶函数

**高阶函数**是指接受另外一个函数作为参数，或返回一个函数的函数。高阶函数不难辨认：看函数签名就够了。如果函数的参数列表里包含函数接口，或该函数返回一个函数接口，那么该函数就是高阶函数。事实上，本章介绍的 Stream 接口中几乎所有的函数都是高阶函数。

> 也就是入参和出参有一个是函数就是了。

comparing 函数，它接受一个函数作为参数，获取相应的值，同时返回一个 Comparator。Comparator 可能会被误认为是一个对象，但它有且只有一个抽象方法，所以实际上是一个函数接口。

**Comparator 实际上应该是个函数**，但是那时的 Java 只有对象，因此才造出了一个类，一个匿名类。成为对象实属巧合，函数接口向正确的方向迈出了一步。

### 3.7 正确使用 Lambda 表达式

**回调函数是一个合法的 Lambda 表达式，但并不能真正帮助用户写出更简单、更抽象的代码**，因为它仍然在指挥计算机执行一个操作。清理掉样板代码很有帮助，但 Java 8 引入的 Lambda 表达式的作用远不止这些。

本章介绍的概念能够帮助用户写出更简单的代码，因为这些概念描述了数据上的操作，**明确了要达成什么转化，而不是说明如何转化**。这种方式写出的代码，潜在的缺陷更少，更直接地表达了程序员的意图。

明确要达成什么转化，而不是说明如何转化的另外一层含义在于**写出的函数没有副作用**。这一点非常重要，这样**只通过函数的返回值就能充分理解函数的全部作用**。**没有副作用的函数不会改变程序或外界的状态。**

**给变量赋值也是一种副作用，而且更难察觉**。在程序的输出中可能很难直接观察到，但是它的确更改了程序的状态。

> 这段话很奇怪，我只可以理解没有副作用这部分。
>
> 一些解释见：[正确使用 Lambda 表达式](一些解释.md#正确使用-lambda-表达式)

```java
ActionEvent localEvent = null;
button.addActionListener(event -> {
    localEvent = event;
});
```

这段代码试图将 event 赋给一个局部变量，**它无法通过编译，但绝非编写错误**。这实际上是语言的设计者**有意为之**，用以鼓励用户使用 Lambda 表达式获取值而不是变量。获取值使用户更容易写出没有副作用的代码。如第二章所述，在 Lambda 表达式中使用局部变量，可以不使用 final 关键字，**但局部变量在既成事实上必须是 final 的**。

无论何时，**将 Lambda 表达式传给 Stream 上的高阶函数，都应该尽量避免副作用**。**唯一的例外是 forEach 方法，它是一个终结方法**。

### 3.8 要点回顾

- 内部迭代将更多控制权交给了集合类。
- 和 Iterator 类似， Stream 是一种内部迭代方式。
- 将 Lambda 表达式和 Stream 上的方法结合起来， 可以完成很多常见的集合操作。

## 第 4 章 类库

本章将详细阐述另一个重要方面：如何使用 Lambda 表达式。即使不需要编写像 Stream 这样重度使用函数式编程风格的类库，学会如何使用 Lambda 表达式也是非常重要的。

Java 8 中的另一个变化是引入了**默认方法**和**接口的静态方法**，它改变了人们认识类库的方式，接口中的方法也可以包含代码体了。

> 这说的应该是 Class::method 这个吧

### 4.1 在代码中使用 Lambda 表达式

这一节的例子以日志打印为例

```java
Logger logger = new Logger();
// 先判断可以避免多于操作，比如不应该打印而expensiveOperation()也会执行
// 但是每次都判断会让代码看着乱七八糟的（纯度低）
if (logger.isDebugEnabled()) {
    logger.debug("Look at this: " + expensiveOperation());
}

// 使用 Lambda 表达式简化日志代码（纯度高）
// lambda表达式使得expensiveOperation()仅在必要时执行（实际等效于上面的方法）
Logger logger = new Logger();
logger.debug(() -> "Look at this: " + expensiveOperation());

public void debug(Supplier<String> message) {
    if (isDebugEnabled()) {
        // message.get()能获取到吗？
        debug(message.get());
    }
}
```

### 4.2 基本类型

只有装箱类型才能作为泛型参数。麻烦的是，由于装箱类型是对象，因此在内存中存在额外开销。在最坏的情况下，同样大小的数组，Integer[] 要比 int[] 多占用 6 倍内存。对于需要大量数值运算的算法来说，装箱和拆箱的计算开销，以及装箱类型占用的额外内存，会明显减缓程序的运行速度。

在 Java 8 中，仅对整型长整型和双浮点型做了特殊处理，因为它们在数值计算中用得最多，特殊处理后的系统性能提升效果最明显。

对基本类型做特殊处理的方法在命名上有明确的规范。

- 如果方法返回类型为基本类型， 则在基本类型前加 To，如图 4-1 中的 ToLongFunction。
- 如果参数是基本类型， 则不加前缀只需类型名即可，如图 4-2 中的 LongFunction。
- 如果高阶函数使用基本类型，则在操作后加后缀 To 再加基本类型，如 mapToLong。

这些基本类型都有与之对应的 Stream， 以基本类型名为前缀， 如 LongStream。

mapToLong 方法返回的不是一个一般的 Stream， 而是一个特殊处理的 Stream。在这个特殊的 Stream 中， map 方法的实现方式也不同，它接受一个 LongUnaryOperator 函数，将一个长整型值映射成另一个长整型值。

**如有可能，应尽可能多地使用对基本类型做过特殊处理的方法，进而改善性能。**

> **`mapToInt` 的核心作用：** 将普通的 `Stream<Object>(Stream<Track>)`转换成特化的 **`IntStream`**。

### 4.3 重载解析

在 Java 中可以重载方法， 造成多个方法有相同的方法名， 但签名确不一样。 这在推断参数类型时会带来问题， 因为系统可能会推断出多种类型。 这时，javac 会挑出最具体的类型。当然，同时存在多个重载方法时，哪个是“最具体的类型” 可能并不明确。

> lambda 表达式类型的推断

将 Lambda 表达式强制转换为 IntPredicate 或 `Predicate<Integer>` 类型可以解决这个问题， 至于转换为哪种类型则取决于要调用哪个函数接口。当然，如果以前你曾自行设计过类库，就可以**将其视为“代码异味”，不该再重载，而应当开始重新命名重载方法**。

总而言之， Lambda 表达式作为参数时， 其类型由它的目标类型推导得出， 推导过程遵循如下规则：

- 如果只有一个可能的目标类型， 由相应函数接口里的参数类型推导得出；
- 如果有多个可能的目标类型， 由最具体的类型推导得出；
- 如果有多个可能的目标类型且最具体的类型不明确， 则需人为指定类型。

### 4.4 `@FunctionalInterface`

事实上，每个用作函数接口的接口都应该添加`@FunctionalInterface` 这个注释。

Java 中有一些接口， 虽然只含一个方法， 但并不是为了使用 Lambda 表达式来实现的。 比如， 有些对象内部可能保存着某种状态， 使用带有一个方法的接口可能纯属巧合。 `java.lang.Comparable` 和 `java.io.Closeable` 就属于这样的情况。

和 Closeable 和 Comparable 接口不同， 为了提高 Stream 对象可操作性而引入的各种新接口， 都需要有 Lambda 表达式可以实现它。 它们存在的意义在于将代码块作为数据打包起来。 因此， 它们都添加了 `@FunctionalInterface` 注释。

该注释会强制 javac 检查一个接口是否符合函数接口的标准。 如果该注释添加给一个枚举类型、 类或另一个注释， 或者接口包含不止一个抽象方法， javac 就会报错。 重构代码时，使用它能很容易发现问题。

> 这个就和@override 一样，不强制但是推荐加上

### 4.5 二进制接口的兼容性

Java 8 中对 API 最大的改变在于集合类。 虽然 Java 在持续演进， 但它一直在保持着向后二进制兼容。和其他编程平台相比， 二进制兼容性一直被视为 Java 的关键优势所在。

Java 8 中为 Collection 接口增加了 stream 方法， 这意味着所有实现了 Collection 接口的类都必须增加这个新方法。 对核心类库里的类来说， 实现这个新方法（比如为 ArrayList 增加新的 stream 方法） 就能就能使问题迎刃而解。

缺憾在于， **这个修改依然打破了二进制兼容性**， 在 JDK 之外实现 Collection 接口的类，例如 MyCustomList， 也仍然需要实现新增的 stream 方法。 这个 MyCustomList 在 Java 8 中无法通过编译， 即使已有一个编译好的版本， 在 JVM 加载 MyCustomList 类时， 类加载器仍然会引发异常。

这是所有使用第三方集合类库的梦魇， 要避免这个糟糕情况， 则需要在 Java 8 中添加新的语言特性： **默认方法**。

> 他所说的兼容不是担心修改自身代码产生的问题，代码都在自己手里，要改也没什么问题。不过接口作为约束行为的东西，第三方也会实现，总不能强制所有实现的人都要改代码。

### 4.6 默认方法

和类不同， 接口没有成员变量， 因此默认方法只能通过调用子类的方法来修改子类本身，避免了对子类的实现做出各种假设。

> 接口中没法调用子类的东西，所以实现很纯粹，不容易影响到子类/实现类。

默认方法的重写规则也有一些微妙之处。 从最简单的情况开始来看： 没有重写。子类没有实现，即调用时用的接口的默认实现。

简言之， **类中重写的方法胜出**。 这样的设计主要是由增加默认方法的目的决定的， 增加默认方法主要是为了在接口上向后兼容。 让类中重写方法的优先级高于默认方法能简化很多继承问题。

<img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch04-image-20251222231532013" alt="image-20251222231532013" style="zoom: 33%;" />

> 也就是继承实现上离得最近的方法

### 4.7 多重继承

接口允许多重继承， 因此有可能碰到两个接口包含签名相同的默认方法的情况。此时， javac 并不明确应该继承哪个接口中的方法， 因此编译器会报错，在类中实现 rock 方法就能解决这个问题（`@override`）。

```java
public class MusicalCarriage
    implements Carriage, Jukebox {
    @Override
    public String rock() {
        // 指定用哪个，或者自己实现
        return Carriage.super.rock();
    }
}
```

三定律
如果对默认方法的工作原理， 特别是在多重继承下的行为还没有把握， 如下三条简单的定律可以帮助大家。

1. **类胜于接口**。 如果在继承链中有方法体或抽象的方法声明， 那么就可以忽略接口中定义的方法。

2. **子类胜于父类**。 如果一个接口继承了另一个接口， 且两个接口都定义了一个默认方法，那么子类中定义的方法胜出。

3. **没有规则三**。 如果上面两条规则不适用， **子类要么需要实现该方法， 要么将该方法声明为抽象方法**。
   其中第一条规则是为了让代码向后兼容。

### 4.8 权衡

Q：在接口中定义方法的诸多变化引发了一系列问题， 既然可用代码主体定义方法， 那 Java 8 中的接口还是旧有版本中界定的代码吗？

A：现在的接口提供了某种形式上的多重继承功能，然而多重继承在以前饱受诟病， Java 因此舍弃了该语言特性， 这也正是 Java 在易用性方面优于 C++ 的原因之一。

> 这段话意思是什么？见[一些解释](一些解释.md#48-权衡-trade-offs-中的-qa-解释)

很多人认为多重继承的问题在于对象状态的继承， 而不是代码块的继承， 默认方法避免了状态的继承， 也因此避免了 C++ 中多重继承的最大缺点。

> 接口主要好在没状态，作者认为这点优于 C++

接口和抽象类之间还是存在明显的区别。**接口允许多重继承，却没有成员变量；抽象类可以继承成员变量，却不能多重继承。**在对问题域建模时，需要根据具体情况进行权衡，而在以前的 Java 中可能并不需要这样。

> 这一小节的观点仅看后半部分就够了

### 4.9 接口的静态方法

Stream 是个接口，`Stream.of` 是接口的静态方法。 _这也是 Java 8 中添加的一个新的语言特性_， 旨在帮助编写类库的开发人员， 但对于日常应用程序的开发人员也同样适用。

> 这是什么语言特性。见[一些解释](一些解释.md#49-接口的静态方法-static-methods-in-interfaces)

人们在编程过程中积累了这样一条经验， 那就是一个包含很多静态方法的类。 有时， 类是一个放置工具方法的好地方， 比如 Java 7 中引入的 Objects 类， 就包含了很多工具方法，这些方法不是具体属于某个类的。

> Object 本身不是一个重要基类吗？包含一些工具方法很正常，这里是要说什么？

当然， 如果一个方法有充分的语义原因和某个概念相关， 那么就应该将该方法和相关的类或接口放在一起， 而不是放到另一个工具类中。 这有助于更好地组织代码， 阅读代码的人也更容易找到相关方法。

> 这段倒是能看明白，类似于充血模型更能方便使用并且实现高内聚。

### 4.10 Optional

reduce 方法的一个重点尚未提及： reduce 方法有两种形式， **一种如前面出现的需要有一个初始值， 另一种变式则不需要有初始值**。 没有初始值的情况下， reduce 的第一步使用 Stream 中的前两个元素。 有时， reduce 操作不存在有意义的初始值， 这样做就是有意义的， 此时， reduce 方法返回一个 Optional 对象。

> 这段翻译的很蹩脚，想引入 Optional 却莫名其妙。

Optional 是为核心类库新设计的一个数据类型， 用来替换 null 值。**使用 null 代表值不存在的最大问题在于 NullPointerException**。 一旦引用一个存储 null 值的变量， 程序会立即崩溃。

使用 Optional 对象有两个目的：

- 首先， Optional 对象鼓励程序员适时检查变量是否为空， 以避免代码缺陷；
- 其次， 它将一个类的 API 中可能为空的值文档化， 这比阅读实现代码要简单很多。

使用 Optional 对象的方式之一是在调用 get() 方法前， 先使用 isPresent 检查 Optional 对象是否有值。 使用 orElse 方法则更简洁， 当 Optional 对象为空时， 该方法提供了一个备选值。 如果计算备选值在计算上太过繁琐， 即可使用 orElseGet 方法。 该方法接受一个 Supplier 对象， 只有在 Optional 对象真正为空时才会调用。

### 4.11 要点回顾

- 使用为基本类型定制的 Lambda 表达式和 Stream， 如 IntStream 可以显著提升系统性能。
- 默认方法是指接口中定义的包含方法体的方法， 方法名有 default 关键字做前缀。
- 在一个值可能为空的建模情况下， 使用 Optional 对象能替代使用 null 值。

## 第 5 章 高级集合类和收集器

### 5.1 方法引用

Lambda 表达式有一个常见的用法： Lambda 表达式经常调用参数：`artist -> artist.getName()`。

Java 8 为其提供了一个简写语法， 叫作方法引用， 帮助程序员重用已有方法：`Classname::methodName`。

需要注意的是， 虽然这是一个方法，但不需要在后面加括号，因为这里并不调用该方法。我们只是提供了和 Lambda 表达式等价的一种结构，在需要时才会调用。凡是使用 Lambda 表达式的地方，就可以使用方法引用。构造函数也有同样的缩写形式：`Artist::new`。

另一个要注意的地方是方法引用自动支持多个参数， 前提是选对了正确的函数接口。方法引用只不过是基于这样的事实， 提供了一种简短的语法而已。

还可以用这种方式创建数组`String[]::new`。

> 这个看着好怪

### 5.2 元素顺序

直观上看， 流是有序的， 因为流中的元素都是按顺序处理的。 这种顺序称为出现顺序。 出现顺序的定义依赖于数据源和对流的操作。

**在一个有序集合中创建一个流时， 流中的元素就按出现顺序排列；如果集合本身就是无序的， 由此生成的流也是无序的。**

流的目的不仅是在集合类之间做转换， 而且同时提供了一组处理数据的通用操作。 有些集合本身是无序的， 但这些操作有时会产生顺序。一些中间操作会产生顺序， 比如对值做映射时， 映射后的值是有序的， 这种顺序就会保留下来。 如果进来的流是无序的， 出去的流也是无序的。

一些操作在有序的流上开销更大， 调用 unordered 方法消除这种顺序就能解决该问题。 大多数操作都是在有序流上效率更高， 比如 filter、 map 和 reduce 等。

比如使用并行流时， forEach 方法不能保证元素是按顺序处理的（ 第 6 章会详细讨论这些内容）。 如果需要保证按顺序处理， 应该使用 forEachOrdered 方法， 它是你的朋友。

### 5.3 使用收集器

仅凭流上方法的签名， 就能判断出这是否是一个及早求值的操作（如 reduce）。这就是收集器， 一种通用的、 从流生成复杂值的结构。 只要将它传给 collect 方法， 所有的流就都可以使用它了。

#### 5.3.1 转换成其他集合

通常情况下， 创建集合时需要调用适当的构造函数指明集合的具体类型。但是调用 toList 或者 toSet 方法时， 不需要指定具体的类型。 Stream 类库在背后自动为你挑选出了合适的类型。

比如， 你可能希望使用 TreeSet， 而不是由框架在背后自动为你指定一种类型的 Set。 此时就可以使用 toCollection， 它接受一个函数作为参数， 来创建集合：

```java
stream.collect(toCollection(TreeSet::new));
```

#### 5.3.2 转换成值

可以利用收集器让流生成一个值。 maxBy 和 minBy 允许用户按某种特定的顺序生成一个值。

```java
// 找出成员最多的乐队
public Optional<Artist> biggestGroup(Stream<Artist> artists) {
    Function<Artist,Long> getCount = artist -> artist.getMembers().count();
    return artists.collect(maxBy(comparing(getCount)));
}

// 找出一组专辑上曲目的平均数
public double averageNumberOfTracks(List<Album> albums) {
    return albums.stream()
        .collect(averagingInt(album -> album.getTrackList().size()));
}
```

#### 5.3.3 数据分块

另外一个常用的流操作是将其分解成两个集合。收集器 partitioningBy， 它接受一个流， 并将其分成两部分。它使用 Predicate 对象判断一个元素应该属于哪个部分， 并根据布尔值返回一个 Map 到列表。 因此， 对于 true List 中的元素， Predicate 返回 true； 对其他 List 中的元素， Predicate 返回 false。

<img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch05-image-20251223230938268" alt="image-20251223230938268" style="zoom: 33%;" />

```java
// 使用方法引用将艺术家组成的 Stream 分成乐队和独唱歌手两部分
public Map<Boolean, List<Artist>> bandsAndSoloRef(Stream<Artist> artists) {
    return artists.collect(partitioningBy(Artist::isSolo));
}
```

#### 5.3.4 数据分组

数据分组是一种更自然的分割数据操作， 与将数据分成 ture 和 false 两部分不同， 可以使用任意值对数据分组。

> 读者可能知道 SQL 中的 group by 操作， 我们的方法是和这类似的一个概念，只不过在 Stream 类库中实现了而已。

#### 5.3.5 字符串

很多时候， 收集流中的数据都是为了在最后生成一个字符串。

```java
// 使用流和收集器格式化艺术家姓名
String result = artists.stream()
                       .map(Artist::getName)
                       .collect(Collectors.joining(", ", "[", "]"));
```

#### 5.3.6 组合收集器

这两个例子中我们都用到了第二个收集器， 用以收集最终结果的一个子集。 这些收集器叫作**下游收集器**。 收集器是生成最终结果的一剂配方， 下游收集器则是生成部分结果的配方， 主收集器中会用到下游收集器。 这种组合使用收集器的方式， 使得它们在 Stream 类库中的作用更加强大。

#### 5.3.7 重构和定制收集器

不合理的重构和滥用特性会使得代码看起来更糟糕。

```java
String result =
    artists.stream()
    .map(Artist::getName)
    // 使用 reduce 操作， 将工作代理给 StringCombiner 对象
    .reduce(new StringCombiner(", ", "[", "]"),
            StringCombiner::add,
            StringCombiner::merge)
    .toString();

String result =
    artists.stream()
    .map(Artist::getName)
    // 使用定制的收集器 StringCollector 收集字符串
    .collect(new StringCollector(", ", "[", "]"));
```

既然已经将所有对字符串的连接操作代理给了定制的收集器， 应用程序就不需要关心 StringCollector 对象的任何内部细节， 它和框架中其他 Collector 对象用起来是一样的。

> 这里有一个之前就应该解释的问题，reduce 应该怎么用？见：[一些解释](一些解释.md#537-reduce-应该怎么用)

一个收集器由四部分组成。

- 首先是一个 Supplier， 这是一个工厂方法， 用来创建容器，它是后续操作的初值。
- 收集器的 accumulator 的作用和 reduce 操作的第二个参数一样， 它结合之前操作的结果和当前值， 生成并返回新的值。
- combine 方法很像 reduce 操作的第三个方法。 如果有两个容器， 我们需要将其合并。

- 收集器的 finisher 方法作用相同。 我们已经将流中的值叠加入一个可变容器中， 但这还不是我们想要的最终结果。 这里调用了 finisher 方法， 以便进行转换。 在我们想创建字符串等不可变的值时特别有用， 这里容器是可变的。

关于收集器， 还有一点一直没有提及， 那就是**特征**。 特征是一组描述收集器的对象， 框架可以对其适当优化。 characteristics 方法定义了特征。

> characteristics 见 [一些解释](一些解释.md#538-收集器的特征-collector-characteristics)

想要收集的最终结果和容器一样是完全有可能的。此时， finisher 方法不需要对容器做任何操作。 更正式地说， 此时的 finisher 方法其实是 identity 函数： 它返回传入参数的值。 如果这样， 收集器就展现出 IDENTITY_FINISH 的特征， 需要使用 characteristics 方法声明。

#### 5.3.8 对收集器的归一化处理

定制收集器其实不难， 但如果你想为自己领域内的类定制一个收集器， 不妨考虑一下其他替代方案。 最容易想到的方案是构建若干个集合对象， 作为参数传给领域内类的构造函数。 如果领域内的类包含多种集合， 这种方式又简单又适用。

除此之外，你还可以使用 reducing 收集器， 它为流上的归一操作提供了统一实现。

```java
String result =
    artists.stream()
    .map(Artist::getName)
    .collect(Collectors.reducing(
        new StringCombiner(", ", "[", "]"),
        // 如果你被这种写法吓到了， 或是感到恶心， 你不是一个人！
        // 这种方式非常低效， 这也是我要定制收集器的原因之一。
        name -> new StringCombiner(", ", "[", "]").add(name),
        StringCombiner::merge))
    .toString();
```

> 这里用的：`Collectors.reducing`，之前用的是`Stream.reduce`。所以签名不同。
>
> 原理解释见：[一些解释](一些解释.md#539-核心疑惑streamreduce-和-collectorsreducing-的区别)

1. 签名不匹配：
   - reducing 的第 2 个参数要求是 Map（T -> U），通过一个元素创建一个新结果。
   - StringCombiner::add 是 Accumulate（Sc.add(s)），它需要一个现有的容器，而不是创建一个新容器。
2. 低效原因：
   - reducing 这种写法强迫你为每一个字符串都 new 一个临时的 StringCombiner（仅仅是为了把它包起来传给 merge）。
   - 如果有 1 万个元素，就得 new 1 万个 StringCombiner，这显然是巨大的浪费。
   - 正解：使用 collect + 自定义 Collector（或者 Collector.of），它可以直接在一个容器上累加，无需重复 new。

### 5.4 一些细节

Lambda 表达式的引入也推动了一些新方法被加入集合类。构建 Map 时， 为给定值计算键值是常用的操作之一， 一个经典的例子就是实现一个缓存。传统的处理方式是先试着从 Map 中取值， 如果没有取到， 创建一个新值并返回。

Java 8 引入了一个新方法 computeIfAbsent， 该方法接受一个 Lambda 表达式， 值不存在时使用该 Lambda 表达式计算新值。

```java
public Artist getArtist(String name) {
    // 算出来之后会把结果写入map中
    return artistCache.computeIfAbsent(name, this::readArtistFromDB);
}
```

Java 8 为 Map 接口新增了一个 forEach 方法， 该方法接受一个 BiConsumer 对象为参数（该对象接受两个参数， 返回空）， 通过内部迭代编写出易于阅读的代码。

```java
Map<Artist, Integer> countOfAlbums = new HashMap<>();
albumsByArtist.forEach((artist, albums) -> {
    countOfAlbums.put(artist, albums.size());
});
```

> 这个特性在后续 java 版本中也有扩充，就是直接起别名，然后直接就可以使用这个别名。

### 5.5 要点回顾

- 方法引用是一种引用方法的轻量级语法， 形如： ClassName::methodName。
- 收集器可用来计算流的最终值， 是 reduce 方法的模拟。
- Java 8 提供了收集多种容器类型的方式， 同时允许用户自定义收集器。

## 第 6 章 数据并行化

从外部迭代到内部迭代的过渡（详见第 3 章）， 确实让编写简洁的代码更加容易， 但这还不是唯一的好处， 另一个好处是程序员不需要手动控制迭代过程了。Stream 使得我们可以不用任何代价就能购直接实现并行化。

### 6.1 并行和并发

并发是两个任务共享时间段， 并行则是两个任务在同一时间发生， 比如运行在多核 CPU 上。 如果一个程序要运行两个任务， 并且只有一个 CPU 给它们分配了不同的时间片， 那么这就是并发， 而不是并行。

<img src="D:\OneDrive\Notes\BookNotes\Java 8 Lambdas\assets\ch06-image-20251225211457083" alt="image-20251225211457083" style="zoom:33%;" />

实际上， 和顺序执行相比， 并行化执行任务时， CPU 承载的工作量更大。

本章会讨论一种特殊形式的并行化： 数据并行化。 数据并行化是指将数据分成块， 为每块数据分配单独的处理单元。

### 6.2 为什么并行化如此重要

阿姆达尔定律让我开始关注并行化的重要性（硬件发展到瓶颈了）。 **阿姆达尔定律**是一个简单规则， 预测了搭载多核处理器的机器提升程序速度的理论最大值。 以一段完全串行化的程序为例， 如果将其一半改为并行化处理， 则不管增加多少处理器， 其理论上的最大速度只是原来的 2 倍。 有了大量的处理器后， 现在这已经是现实了，问题的求解时间将完全取决于它可被分解成几个部分。

### 6.3 并行化流操作

我们先要问自己一个问题： 并行化运行基于流的代码是否比串行化运行更快？ 输入流的大小并不是决定并行化是否会带来速度提升的唯一因素， 性能还会受到编写代码的方式和核的数量的影响。

### 6.4 模拟系统

蒙特卡洛模拟法会重复相同的模拟很多次， 每次模拟都使用随机生成的种子。 每次模拟的结果都被记录下来， 汇总得到一个对系统的全面模拟。 蒙特卡洛模拟法被大量用在工程、 金融和科学计算领域。

### 6.5 限制

为了发挥并行流框架的优势， 写代码时必须遵守一些规则和限制。

之前调用 reduce 方法， 初始值可以为任意值， 为了让其在并行化时能工作正常， 初值必须为组合函数的恒等值。 拿恒等值和其他值做 reduce 操作时， 其他值保持不变。

> 毕竟分别执行再合并，每次合并都加上初值，如果合并了好多遍就有问题了。

reduce 操作的另一个限制是组合操作必须符合结合律。 这意味着只要序列的值不变， 组合操作的顺序不重要。

要避免的是持有锁。 流框架会在需要时， 自己处理同步操作， 因此程序员没有必要为自己的数据结构加锁。

在要对流求值时， 不能同时处于两种模式， 要么是并行的， 要么是串行的。 如果同时调用了 parallel 和 sequential 方法， 最后调用的那个方法起效。

### 6.6 性能

影响并行流性能的主要因素有 5 个， 依次分析如下。

- 数据大小

  输入数据的大小会影响并行化处理对性能的提升。 **将问题分解之后并行化处理， 再将结果合并会带来额外的开销。** 因此只有数据足够大、 每个数据处理管道花费的时间足够多时， 并行化处理才有意义。 6.3 节讨论过。

- 源数据结构

  每个管道的操作都基于一些初始数据源， 通常是集合。 将不同的数据源分割相对容易，这里的开销影响了在管道中并行处理数据时到底能带来多少性能上的提升。

- 装箱

  处理基本类型比处理装箱类型要快。

- 核的数量

  极端情况下， 只有一个核， 因此完全没必要并行化。 显然， 拥有的核越多， 获得潜在性能提升的幅度就越大。 在实践中， **核的数量不单指你的机器上有多少核， 更是指运行时你的机器能使用多少核**。 这也就是说同时运行的其他进程， 或者线程关联性（强制线程在某些核或 CPU 上运行） 会影响性能。

- 单元处理开销

  比如数据大小， 这是一场并行执行花费时间和分解合并操作开销之间的战争。 花在流中每个元素身上的时间越长， 并行操作带来的性能提升越明显

使用并行流框架， 理解如何分解和合并问题是很有帮助的。 这让我们能够知悉底层如何工作， 但却不必了解框架的细节。

根据问题的分解方式， 初始的数据源的特性变得尤其重要， 它影响了分解的性能。 直观上看， 能重复将数据结构对半分解的难易程度， 决定了分解操作的快慢。 能对半分解同时意味着待分解的值能够被等量地分解。

我们可以根据性能的好坏， 将核心类库提供的通用数据结构分成以下 3 组。

- 性能好

  ArrayList、 数组或 IntStream.range， 这些数据结构支持随机读取， 也就是说它们能轻而易举地被任意分解。

- 性能一般

  HashSet、 TreeSet， 这些数据结构不易公平地被分解， 但是大多数时候分解是可能的。

- 性能差

  有些数据结构难于分解， 比如， 可能要花 O(N) 的时间复杂度来分解问题。 其中包括 LinkedList， 对半分解太难了。 还有 Streams.iterate 和 BufferedReader.lines， 它们长度未知， 因此很难预测该在哪里分解。

初始的数据结构影响巨大。 举一个极端的例子， 对比对 10 000 个整数并行求和， 使用 ArrayList 要比使用 LinkedList 快 10 倍。

理想情况下， 一旦流框架将问题分解成小块， 就可以在每个线程里单独处理每一小块， 线程之间不再需要进一步通信。 无奈现实不总遂人愿！

在讨论流中单独操作每一块的种类时， 可以分成两种不同的操作： 无状态的和有状态的。**无状态操作整个过程中不必维护状态， 有状态操作则有维护状态所需的开销和限制。**如果能避开有状态， 选用无状态操作， 就能获得更好的并行性能。 **无状态操作**包括 map、filter 和 flatMap， **有状态操作**包括 sorted、 distinct 和 limit。

### 6.7 并行化数组操作

表 6-1： 数组上的并行化操作

| 方法名         | 操　　作                                           |
| -------------- | -------------------------------------------------- |
| parallelPrefix | 任意给定一个函数， 计算数组的和                    |
| parallelSetAll | 使用 Lambda 表达式更新数组元素（可用于初始化数组） |
| parallelSort   | 并行化对数组元素排序                               |

使用这些方法有一点要小心： 它们**改变了传入的数组**， 而没有创建一个新的数组。

parallelPrefix 操作擅长对时间序列数据做累加， 它会更新一个数组， 将每一个元素替换为当前元素和其前驱元素的和， 这里的“和” 是一个宽泛的概念， 它不必是加法， 可以是任意一个 BinaryOperator。

### 6.8 要点回顾

- 数据并行化是把工作拆分， 同时在多核 CPU 上执行的方式。
- 如果使用流编写代码， 可通过调用 parallel 或者 parallelStream 方法实现数据并行化操作。
- 影响性能的五要素是： 数据大小、 源数据结构、 值是否装箱、 可用的 CPU 核数量， 以及处理每个元素所花的时间。
