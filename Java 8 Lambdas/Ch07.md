# 第 7 章 测试、调试和重构（介绍一些让测试和调试 Lambda 表达式变得容易的技巧）

> 如果读者对如何正确地使用测试驱动开发（TDD） 感兴趣， 我极力推荐大家阅读 Kent Beck 写的 Test-Driven Development， 以及由 Steve Freeman 和 Nat Pryce 写的 Growing Object-Oriented Software, Guided by Tests（两本书均由 Addison-Wesley 出版社出版）。

本章主要探讨如何在代码中使用 Lambda 表达式的技术， 也会说明什么情况下不应该（直接） 使用 Lambda 表达式。 本章还讲述了如何调试大量使用 Lambda 表达式和流的程序。

> 这一章的翻译有很大问题

## 7.1 重构候选项

使用 Lambda 表达式重构代码有个时髦的称呼： Lambda 化（读作 lambda-fi-cation， 执行重构的程序员叫作 lamb-di-fiers 或者有责任心的程序员）。Java 8 中的核心类库就曾经历过这样一场重构。 在选择内部设计模型时， 想想以何种形式向外展示 API 是大有裨益的。

### 7.1.1 进进出出、 摇摇晃晃

**如果你发现自己的代码不断地查询和操作某对象， 目的只为了在最后给该对象设个值， 那么这段代码就本该属于你所操作的对象。**

```java
// logger 对象使用 isDebugEnabled 属性避免不必要的性能开销
Logger logger = new Logger();
// 这段代码不好之前讲过，频繁在主要流程里判断，啰嗦纯度低
if (logger.isDebugEnabled()) {
    logger.debug("Look at this: " + expensiveOperation());
}
```

这种反模式通过传入代码即数据的方式很容易解决。 与其查询并设置一个对象的值， 不如传入一个 Lambda 表达式， 该表达式按照计算得出的值执行相应的行为。当程序处于调试级别， 并且检查是否使用 Lambda 表达式的逻辑被封装在 Logger 对象中时， 才会调用 Lambda 表达式。

```java
// 使用 Lambda 表达式简化记录日志代码
Logger logger = new Logger();
logger.debug(() -> "Look at this: " + expensiveOperation());
```

上述记录日志的例子也展示了如何使用 Lambda 表达式更好地面向对象编程（OOP）， **面向对象编程的核心之一是封装局部状态， 比如日志的级别**。 第一个版本的代码做得不是很好，isDebugEnabled 方法暴露了内部状态。 如果使用 Lambda 表达式， 外面的代码根本不需要检查日志级别。

> “好的方式”是：你只需要把这句代码打包成一个 Lambda 扔进去，什么时候执行、要不要执行，全权交给 Logger 内部去决定。 这样你就只要写一行代码，既省事，性能又好（因为不需要打印时 Lambda 根本不会被执行）。

### 7.1.2 孤独的覆盖

另一种代码异味是使用继承， 其目的只是为了覆盖一个方法。

```java
ThreadLocal<Album> thisAlbum = new ThreadLocal<Album> () {
    @Override protected Album initialValue() {
        return database.lookupCurrentAlbum();
    }
};

// lambda代替匿名类
ThreadLocal<Album> thisAlbum
    = ThreadLocal.withInitial(() -> database.lookupCurrentAlbum());
```

我们认为第二个例子优于前一个有以下几个原因。

- 任何已有的 Supplier<Album> 实例不需要重新封装， 就可以在此使用， 这鼓励了重用和组合
- 代码短小精悍就是个优势，且结构清晰，信噪比低
- JVM 会少加载一个类

有趣的是， **在 Java 8 以前， 这并不是一个反模式， 而是惯用的代码编写方式**， 就像使用匿名内部类传递行为一样， 都不是反模式， 而是在 Java 中表达你所想的唯一方式。 随着语言的演进， 编程习惯也要与时俱进。

### 7.1.3 同样的东西写两遍

**不要重复你劳动（Don’t Repeat Yourself， DRY）** 是一个众所周知的模式， 它的反面是同样的东西写两遍（Write Everything Twice， WET）。 这种代码异味多见于重复的样板代码， 产生了更多需要测试的代码， 这样的代码难于重构， 一改就坏。

不是所有 WET 的情况都适合 Lambda 化。 有时， 重复是唯一可以避免系统过紧耦合的方式。

这里有一个信号可以参考：**如果有一个整体上大概相似的模式， 只是行为上有所不同， 就可以试着加入一个 Lambda 表达式。**

流不会提供一个方法统计每张专辑上的信息——这是程序员要自己编写的领域知识。 这也是在 Java 8 出现之前很难编写的领域方法， 因为每个方法都不一样。

> 和领域相关的代码需要自己定制

```java
// 使用领域方法重构 Order 类
public long countFeature(ToLongFunction<Album> function) {
    return albums.stream()
        .mapToLong(function)
        .sum();
}
// 行为参数化，传不同的lambda，不过太复杂的化会适得其反
public long countTracks() {
    return countFeature(album -> album.getTracks().count());
}
public long countRunningTime() {
    return countFeature(album -> album.getTracks()
                        .mapToLong(track -> track.getLength())
                        .sum());
}
public long countMusicians() {
    return countFeature(album -> album.getMusicians().count());
}
```

## 7.2 Lambda 表达式的单元测试

Lambda 表达式给单元测试带来了一些麻烦， Lambda 表达式没有名字， 无法直接在测试代码中调用。

你可以在测试代码中复制 Lambda 表达式来测试， 但这种方式的副作用是测试的不是真正的实现。

解决该问题有两种方式。**第一种是将 Lambda 表达式放入一个方法**测试， 这种方式要测那个方法， 而不是 Lambda 表达式本身。

> 翻译很糟糕，这里明确提到第一种方法，后面没有对应的第二种方法，看似流畅经不起上下文比对

**第二种方式是请不要用 Lambda 表达式。**（或者是：将 Lambda 表达式转换为方法引用）。

在这个重构案例中， 我们把复杂的 Lambda 表达式提取成一个普通方法， 然后在 stream 中使用**方法引用**调用它。 这样你就可以对这个方法进行常规的单元测试。

## 7.3 在测试替身（Mock）中使用 Lambda 表达式

编写单元测试的常用方式之一是使用**测试替身**描述系统中其他模块的期望行为。这种方式很有用， 因为单元测试可以脱离其他模块来测试你的类或方法， 测试替身让你能用单元测试来实现这种隔离。

> 测试替身也常被称为模拟， 事实上测试存根和模拟都属于测试替身。 区别是模拟可以验证代码的行为。 读者若想了解更多有关这方面的信息， 请阅读 Martin Fowler 的相关文章（<http://martinfowler.com/articles/mocksArentStubs.html）。>

测试代码时， 使用 Lambda 表达式的最简单方式是**实现轻量级的测试存根**。如果交互的类本身就是一个函数接口， 实现这样的存根就非常简单和自然。

> 这段话的核心是在讲：在单元测试中，Lambda 表达式是制造“假对象”（测试替身/Mock）的神器。它可以让你不用写一大堆繁琐的类，直接就能定义一个“假行为”。
>
> 先理解什么是**“测试替身 (Test Double)”**。 简单说，就是你在测试 A 的时候，A 依赖了 B。为了只测 A，你不想真的去创建 B（可能 B 很复杂、连数据库等），于是你就造了一个 “假的 B”。

如果要向代码传入一个 Lambda 表达式， 最好确保 Lambda 表达式也通过测试。 多数的测试替身都很复杂， 使用 Mockito 这样的框架有助于更容易地产生测试替身。

```java
// 使用 Lambda 表达式编写测试替身， 这是一个返回固定结果的 Mock
List<String> list = mock(List.class);
// inv和otherlist不是一个东西，就是刻意返回的otherlist
when(list.size()).thenAnswer(inv -> otherList.size()); // Lambda 实现 Answer 接口
assertEquals(3, list.size());
```

Mockito 使用 `Answer` 接口允许用户提供其他行为， 此时 `Answer` 就是一个函数接口。换句话说， 这是我们的老朋友： 代码即数据。

> 这一段是说，因为 Mockito 的接口兼容 Lambda，你可以把一段**“动态的逻辑”**（代码）像传数据一样传给 Mock 对象。这也再次印证了“代码即数据”的思想。

## 7.4 惰性求值和调试

调试时通常会设置断点， 单步跟踪程序的每一步。使用流时， 调试可能会变得更加复杂，因为迭代已交由类库控制， 而且很多流操作是惰性求值的。

调试 Lambda 表达式（以及 Stream）通常比较棘手，因为：

1. **没有名字**：堆栈跟踪 (Stack Trace) 里全是 `lambda$main$0` 这种看不懂的名字。
2. **惰性求值**：有时候断点打进去了，但你为了看中间结果，可能会扰乱整个流的执行。

## 7.5 日志和打印消息

日志和打印消息在流中很难做到， 因为一些中间步骤是惰性求值的，并且流只能使用一次。

## 7.6 解决方案： peak

流有一个方法让你能查看每个值， 同时能继续操作流。 这就是 peek 方法。使用 peek 方法还能以同样的方式， 将输出定向到现有的日志系统中， 比如 log4j、 `java.util.logging` 或者 slf4j。

```java
Set<String> nationalities
    = album.getMusicians()
    .filter(artist -> artist.getName().startsWith("The"))
    .map(artist -> artist.getNationality())
    // 使用 peek 方法记录中间值
    .peek(nation -> System.out.println("Found nationality: " + nation))
    .collect(Collectors.<String>toSet());
```

**要点：**

- `peek` 主要用于调试。
- 不要在 `peek` 里写有副作用（修改状态）的代码，虽然技术上可行，但这是坏习惯。

## 7.7 在流中间设置断点

为了像调试循环那样一步一步跟踪， 可在 peek 方法中加入断点， 这样就能逐个调试流中的元素了。

此时， peek 方法可知包含一个空的方法体， 只要能设置断点就行。 有一些调试器不允许在空的方法体中设置断点， 此时， 我将值简单地映射为其本身， 这样就有地方设置断点了，虽然这样做不够完美， 但只要能工作就行。

## 7.8 要点回顾

- 重构遗留代码时考虑如何使用 Lambda 表达式， 有一些通用的模式。
- 如果想要对复杂一点的 Lambda 表达式编写单元测试， 将其抽取成一个常规的方法。
- peek 方法能记录中间值， 在调试时非常有用。

> 记住：Lambda 是为了让代码更清晰，而不是为了炫技。
