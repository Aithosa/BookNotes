# 第 8 章 设计和架构的原则 （解释现有的那些良好的软件设计原则如何应用到 Lambda 表达式上）

本章将探索如何使用 Lambda 表达式实现 SOLID 原则， 该原则是开发良好面向对象程序的准则。 使用 Lambda 表达式， 还能改进一些现有的设计模式。

不同人对于什么是好代码， 什么是坏代码， 存在分歧很正常。引入 Lambda 表达式后， 又多了一个话题。

> lambda 表达式和函数式编程之前还有很多人说是防御式编程，不过 AI 兴起之后应该会有所缓解。

## 8.1 Lambda 表达式改变了设计模式

从某种程度上来说， 设计模式将解决特定问题的最佳实践途径固定了下来。

没有永远的最佳实践。 以曾经风靡一时的单例模式为例， 该模式确保只产生一个对象实例。 在过去十年中， 人们批评它让程序变得更脆弱， 且难于测试。 敏捷开发的流行，让测试显得更加重要， 单例模式的这个问题把它变成了一个反模式： 一种应该避免使用的模式。

> 这段我感觉很抽象，笔记上有一些解释：[一些解释](一些解释.md#81-单例成为反模式)

本书的重点并不是讨论设计模式如何变得过时， 相反， 我们讨论的是如何使用 Lambda 表达式， 让现有设计模式变得更好、 更简单， 或者在某些情况下， 有了不同的实现方式。Java 8 引入的新语言特性是所有这些设计模式变化的推动因素。

### 8.1.1 命令者模式

命令者是一个对象， 它封装了调用另一个方法的所有细节， 命令者模式使用该对象， 可以编写出根据运行期条件， 顺序调用方法的一般化代码。

> 我是个“懒惰的” 程序员， 喜欢将通用的工作流定义成宏。 我说“懒惰” 了吗？ 我的意思其实是提高工作效率。

```java
// 使用命令者模式构建宏
Macro macro = new Macro();
macro.record(new Open(editor));
macro.record(new Save(editor));
macro.record(new Close(editor));
macro.run();

// 使用 Lambda 表达式构建宏
Macro macro = new Macro();
macro.record(() -> editor.open());
macro.record(() -> editor.save());
macro.record(() -> editor.close());
macro.run();

// 使用方法引用构建宏
Macro macro = new Macro();
macro.record(editor::open);
macro.record(editor::save);
macro.record(editor::close);
macro.run();
```

命令者模式只是一个可怜的程序员使用 Lambda 表达式的起点。 使用 Lambda 表达式或是方法引用， 能让代码更简洁， 去除了大量样板代码， 让代码意图更加明显。

宏只是使用命令者模式的一个例子， 它被大量用在实现组件化的图形界面系统、 撤销功能、 线程池、 事务和向导中。

> 在核心 Java 中， 已经有一个和 Action 接口结构一致的函数接口——Runnable。我们可以在实现上述宏程序中直接使用该接口， 但在这个例子中， 似乎 Action 是一个更符合我们待解问题的词汇， 因此我们创建了自己的接口。

### 8.1.2 策略模式

策略模式能在运行时改变软件的算法行为。 如何实现策略模式根据你的情况而定， 但其主要思想是定义一个通用的问题， 使用不同的算法来实现， 然后将这些算法都封装在一个统一接口的背后。

```java
// 使用具体的策略类初始化 Compressor
Compressor gzipCompressor = new Compressor(new GzipCompressionStrategy());
gzipCompressor.compress(inFile, outFile);

Compressor zipCompressor = new Compressor(new ZipCompressionStrategy());
zipCompressor.compress(inFile, outFile);

// 使用 Lambda 表达式或者方法引用可以去掉样板代码
// 使用方法引用初始化 Compressor
Compressor gzipCompressor = new Compressor(GZIPOutputStream::new);
gzipCompressor.compress(inFile, outFile);

Compressor zipCompressor = new Compressor(ZipOutputStream::new);
zipCompressor.compress(inFile, outFile);
```

### 8.1.3 观察者模式

在观察者模式中， 被观察者持有一个观察者列表。 当被观察者的状态发生改变， 会通知观察者。

> 大量应用于基于 MVC 的 GUI 工具中， 以此让模型状态发生变化时， 自动刷新视图模块， 达到二者之间的解耦。

```java
// 使用类的方式构建用户代码
Moon moon = new Moon();
moon.startSpying(new Nasa());
moon.startSpying(new Aliens());
moon.land("An asteroid");
moon.land("Apollo 11");

// 使用 Lambda 表达式构建用户代码（似乎有点复杂了）
Moon moon = new Moon();
moon.startSpying(name -> {
    if (name.contains("Apollo"))
        System.out.println("We made it!");
});
moon.startSpying(name -> {
    if (name.contains("Apollo"))
        System.out.println("They're distracted, lets invade earth!");
});
moon.land("An asteroid");
moon.land("Apollo 11")
```

**无论使用观察者模式或策略模式， 实现时采用 Lambda 表达式还是传统的类， 取决于策略和观察者代码的复杂度。**然而在有些情况下， 观察者本身就是一个很复杂的类， 这时将很多代码塞进一个方法中会大大降低代码的可读性。

> 从某种角度来说， 将大量代码塞进一个方法会让可读性变差是决定如何使用 Lambda 表达式的黄金法则。

### 8.1.4 模板方法模式

开发软件时一个常见的情况是**有一个通用的算法， 只是步骤上略有不同**。 我们希望不同的实现能够遵守通用模式， 保证它们使用了同一个算法， 也是为了让代码更加易读。 一旦你从整体上理解了算法， 就能更容易理解其各种实现。

模板方法模式是为这些情况设计的： 整体算法的设计是一个抽象类， 它有一系列抽象方法， 代表算法中可被定制的步骤， 同时这个类中包含了一些通用代码。 算法的每一个变种由具体的类实现， 它们重写了抽象方法， 提供了相应的实现。

> 类似于有公用部分，也有可定制环节

模板方法模式真正要做的是将一组方法调用按一定顺序组织起来。 如果用函数接口表示函数， 用 Lambda 表达式或者方法引用实现这些接口， 相比使用继承构建算法， 就会得到极大的灵活性。

## 8.2 使用 Lambda 表达式的领域专用语言

领域专用语言（DSL） 是针对软件系统中某特定部分的编程语言。 它们通常比较小巧， 表达能力也不如 Java 这样能应对大多数编程任务的通用语言强。 DSL 高度专用： 不求面面俱到， 但求有所专长。

人们通常将 DSL 分为两类： **内部 DSL** 和**外部 DSL**。 **外部 DSL 脱离程序源码编写， 然后单独解析和实现**。 比如级联样式表（CSS） 和正则表达式， 就是常用的外部 DSL。**而内部 DSL 嵌入编写它们的编程语言中。**

> 这里举的例子是 BDD。BDD 是测试驱动开发（TDD） 的一个变种， 它的重点是描述程序的行为， 而非一组需要通过的单元测试。
>
> 可以看看这一节的例子。

流畅性的一方面表现在 DSL 是否是 IDE 友好的。 换句话说， 你只需记住少量知识， 然后用代码自动补全功能补齐代码。另一个值得注意的是大多数测试框架提供了大量注释， 或者很多外部“魔法”， 或者借助
于反射。

> 最后一段提到的“无魔法、无反射”。这不仅让代码运行快，也让代码逻辑对开发者是透明的（所见即所得），这也是一种广义上的“流畅”（理解上的无障碍）

## 8.3 使用 Lambda 表达式的 SOLID 原则

SOLID 原则是设计面向对象程序时的一些基本原则。每种原则都对应着一系列潜在的代码异味， 并为其提供了解决方案。

### 8.3.1 单一功能原则

**程序中的类或方法只能有一个改变的理由。**如果你的类有多个功能，一个功能引发的代码变化会影响该类的其他功能。 这可能会引入缺陷， 还会影响代码演进的能力。

单一功能原则不止于此： **一个类不仅要功能单一， 而且还需将功能封装好**。 换句话说， 如果我想改变输出格式， 那么只需改动负责输出的类， 而不必关心负责制表的类。

**这是强内聚性设计的一部分**。 说一个类是内聚的， 是指它的方法和属性需要统一对待， 因为它们紧密相关。 如果你试着将一个内聚的类拆分， 可能会得到刚才创建的那两个类。

Lambda 表达式在方法级别能更容易实现单一功能原则。

改进代码还有一个现实的原因， 如果需要对一个很大的 upTo 计数， 我们希望可以并行操作。 没错， **线程模型也是代码的职责之一！**

> 我有点担心滥用 stream 会不会对性能造成影响。我们之前讨论过可读性的问题了。

### 8.3.2 开闭原则

**软件应该对扩展开放， 对修改闭合**。开闭原则的首要目标和单一功能原则类似： **让软件易于修改**。开闭原则保证已有的类在不修改内部实现的基础上可扩展， 这样就努力避免了上述问题。

不改变实现怎么能扩展一个类的功能呢？ 答案是**借助于抽象， 可插入新的功能**。

高阶函数也展示出了同样的特性： 对扩展开放， 对修改闭合。

这符合开闭原则， 因为不用修改 ThreadLocal 类， 就能得到新的行为。 给 withInitial 方法传入不同的工厂方法， 就能得到拥有不同行为的 ThreadLocal 实例。通过传入不同的 Lambda 表达式， 可以得到完全不同的行为。

```java
// ThreadLocal 标识符
// 或者这样实现
AtomicInteger threadId = new AtomicInteger();
ThreadLocal<Integer> localId
    = ThreadLocal.withInitial(() -> threadId.getAndIncrement());
// 使用
int idForThisThread = localId.get();
```

> 这里线程第一次调用当然是空的，然后就会执行 lambda，之后再次执行因为触发过初始化了，多以每次获取都是同一个值。
>
> 其他线程之后第一次调用是空的，会触发初始化，不过这次初始化时 threadId 已经不是初值了，会在上一个线程的值之上自增。
>
> 因为 threadId 并没有使用 ThreadLocal，他不受保护。threadId 是被 所有线程共享的。

对开闭原则的另外一种理解和传统的思维不同， 那就是**使用不可变对象实现开闭原则**。 不可变对象是指一经创建就不能改变的对象。

“不可变性” 一词有两种解释： **观测不可变性**和实现不可变性。 观测不可变性是指在其他对象看来， 该类是不可变的； 实现不可变性是指对象本身不可变。 实现不可变性意味着观测不可变性， 反之则不一定成立。

`java.lang.String` 宣称是不可变的， 但事实上只是观测不可变， 因为它在第一次调用 hashCode 方法时缓存了生成的散列值。

> 之所以在这样一本讲解 Lambda 表达式的书中谈及不可变对象， 是因为它们都是函数式编程中耳熟能详的概念， 这里也是 Lambda 表达式的发源地。 它们生来就符合我在本书中讲述的编程风格。

我们说不可变对象实现了开闭原则， 是因为**它们的内部状态无法改变， 可以安全地为其增加新的方法**。 **新增加的方法无法改变对象的内部状态， 因此对修改是闭合的； 但它们又增加了新的行为， 因此对扩展是开放的**。

因其天生线程安全的特性， 不可变对象引起了人们的格外注意。 它们没有内部状态可变，因此可以安全地在不同线程之间共享。

如果我们回顾这几种方式， 会发现已经偏离了传统的开闭原则。 事实上， 在 Bertrand Meyer 第一次引入这个原则时， 原意是一旦实现后， 类就不允许改动了。当然这不成为忽视这一原则的理由， 只是说明了所谓的原则
只应作为指导， 而不应教条地全盘接受， 走向极端。

我认为还有一点值得思考， **在 Java 8 中， 使用抽象插入多个类， 或者使用高阶函数来实现开闭原则其实是一样的。 因为抽象需要使用一个接口或抽象类来定义方法， 这其实就是一种多态的使用方式**。

在 Java 8 中， 任何传入高阶函数的 Lambda 表达式都由一个函数接口表示， 高阶函数负责调用其唯一的方法， 根据传入 Lambda 表达式的不同， 行为也不同。 这其实也是在用多态来实现开闭原则。

### 8.3.3 依赖反转原则

**抽象不应依赖细节， 细节应该依赖抽象。**

让程序变得死板、 脆弱、 难于改变的方法之一是将上层业务逻辑和底层粘合模块的代码混在一起， 因为这两样东西都会随着时间发生变化。

**依赖反转原则的目的是让程序员脱离底层粘合代码， 编写上层业务逻辑代码**。 这就让上层代码依赖于底层细节的抽象， 从而可以重用上层代码。 这种模块化和重用方式是双向的：既可以替换不同的细节重用上层代码， 也可以替换不同的业务逻辑重用细节的实现。

编写模块的实现依赖于这种抽象。 在运行时传入具体的实现细节， 这就是依赖反转原则的工作原理。

具体到 Lambda 表达式， 我们之前遇到的很多高阶函数都符合依赖反转原则。比如 map 函数重用了在两个集合之间转换的代码。 map 函数不依赖于转换的细节， 而是依赖于抽象的概念。 在这里， 就是依赖函数接口： Function。

```java
// 剥离了文件处理功能后的业务逻辑
public List<String> findHeadings(Reader input) {
    return withLinesOf(input,
                       lines -> lines.filter(line -> line.endsWith(":"))
                       .map(line -> line.substring(0, line.length()-1))
                       .collect(toList()),
                       HeadingLookupException::new);
}

// 定义 withLinesOf 方法
private <T> T withLinesOf(Reader input,
                          Function<Stream<String>, T> handler,
                          Function<IOException, RuntimeException> error) {
    try (BufferedReader reader = new BufferedReader(input)) {
        return handler.apply(reader.lines());
    } catch (IOException e) {
        throw error.apply(e);
    }
}
```

> 我以前觉得这东西有点像回调，就是传进去一个行为，到时候用这个行为自动处理。
>
> 一些解释见： [一些解释](一些解释.md#82-环绕执行模式-execute-around-pattern-的利弊)

总结下来， 高阶函数提供了反转控制， 这就是依赖反转的一种形式， 可以很容易地和 Lambda 表达式一起使用。 依赖反转原则另外值得注意的一点是待依赖的抽象不必是接口。

## 8.4 进阶阅读

长期以来， “Bob 大叔” 是 SOLID 原则的推动者， 他撰写了大量有关该主题的文章和书籍，也多次就该主题举行过演讲。 如果你想免费从他那里获取一些相关知识， 可访问 Object Mentor 官方网站（http://www.objectmentor.com/resources/publishedArticles.html）， 在“设计模式” 主题下有一系列详述设计原则的文章。

如果你想深入理解领域专用语言， 包括内部领域专用语言和外部领域专用语言， 推荐大家阅读 Martin Fowler 和 Rebecca Parsons 合著的 Domain-Specific Languages（Addison-Wesley 出版社出版） 一书。

## 8.5 要点回顾

- Lambda 表达式能让很多现有设计模式更简单、 可读性更强， 尤其是命令者模式。
- 在 Java 8 中， 创建领域专用语言有更多的灵活性。
- 在 Java 8 中， 有应用 SOLID 原则的新机会。
