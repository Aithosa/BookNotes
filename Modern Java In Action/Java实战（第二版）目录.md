# Java 实战（第二版）

## 第一部分 基础知识

- **第 1 章 Java 8、 9、 10 以及 11 的变化** [18]
  - Lambda 表达式、方法引用、流和默认方法，为学习后面的内容做准备
- **第 2 章 通过行为参数化传递代码** [14]
  - 行为参数化是 Java 8 非常依赖的一种软件开发模式，也是引入 Lambda 表达式的主要原因
- **第 3 章 Lambda 表达式** [31]
  - 对 Lambda 表达式和方法引用进行全面介绍

## 第二部分 使用流进行函数式数据处理：详细讨论新的 Stream API

- **第 4 章 引入流** [13]

  - 介绍流的概念，并解释它们与集合有何异同

- **第 5 章 使用流** [30]

  - 讨论为了表达复杂的数据处理查询可以使用的流操作

- **第 6 章 用流收集数据** [62]

  - 介绍收集器—Stream API 的一个功能，可以让你表达更为复杂的数据处理查询

- **第 7 章 并行数据处理与性能** [22]
  - 探讨流如何得以自动并行执行，并利用多核架构的优势

## 第三部分 使用流和 Lambda 进行高效编程：探索 Java 8 和 Java 9 的多个主题，介绍高级编程思想（本书后续内容并不依赖于此）

- **第 8 章 Collection API 的增强功能** [12]

  - 探讨 Java 8 和 Java 9 对 Collection API 的增强

- **第 9 章 重构、测试和调试** [20]

  - 探讨如何利用 Java 8 的新功能和一些秘诀来改善你现有的代码
  - 探讨一些重要的软件开发技术，如设计模式、重构、测试和调试

- **第 10 章 基于 Lambda 的领域特定语言** [29]
  - 介绍依据领域特定语言（ domain-specific language， DSL）实现 API 的思想（譬如 Comparator、 Stream 以及 Collector 接口）

## 第四部分 无所不在的 Java：介绍 Java 8 和 Java 9 中新增的多个特性

- **第 11 章 用 Optional 取代 null** [20]
- **第 12 章 新的日期和时间 API** [14]
- **第 13 章 默认方法** [16]

  - 讨论默认方法是什么，如何利用它们来以兼容的方式演变 API

- **第 14 章 Java 模块系统** [19]
  - Java 9 的主要改进，使大型系统能够以文档化和可执行的方式进行模块化

## 第五部分 提升 Java 的并发性：用 Java 编写高效的函数式程序

- **第 15 章 `CompletableFuture `及反应式编程背后的概念** [27]
  - 从宏观的角度介绍异步 API 的思想，包括 Future、反应式编程背后的“发布–订阅”协议（封装在 Java 9 的 Flow API 中）
  
- **第 16 章 `CompletableFuture`：组合式异步编程** [25]
  - 用声明性方式表达复杂的异步计算，从而让 Stream API 的设计并行化
  
- **第 17 章 反应式编程** [22]
  - 详细介绍 Java 9 的 Flow API，并提供反应式编程的实战代码解析

## 第六部分 函数式编程以及 Java 未来的演进

- **第 18 章 函数式的思考** [12]
  - 完整的函数式编程教程
  
- **第 19 章 函数式编程的技巧** [23]

  - 包括高阶函数、柯里化、持久化数据结构、延迟列表和模式匹配

- **第 20 章 面向对象和函数式编程的混合：Java 和 Scala 的比较** [14]
- **第 21 章 结论以及 Java 的未来** [14]

## 附录

- **附录 A 其他语言特性的更新**
  - 总结了本书未讨论的一些 Java 8 的小特性
- **附录 B 其他类库的更新**
  - 概述了 Java 库的其他主要扩展
- **附录 C 如何以并发方式在同一个流上执行多种操作**
  - 第二部分的延续，介绍了流的高级用法
- **附录 D Lambda 表达式和 JVM 字节码**
  - 探讨了 Java 编译器在幕后是如何实现 Lambda 表达式的
